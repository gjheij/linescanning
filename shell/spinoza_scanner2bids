#!/usr/bin/env bash

#---------------------------------------------------------------------------------------------------------
# check if there's is a setup file containing the major paths and source it if it exists
call_loadsetup

#---------------------------------------------------------------------------------------------------------
# Create help text
function Usage {
    cat <<EOF

---------------------------------------------------------------------------------------------------
spinoza_scanner2bids

convert raw data from the scanner to nifti format. Depending on which session we're analyzing, we'll
use either call_dcm2niix.py (session 1 - which is FromScannerToBIDS.py from M. Aquil) which can deal
nicely with the anatomical and functional stuff or call_dcm2niix.sh, which is more specific for the
line scanning stuff.

Input options:
  -s <subject>        subject ID (e.g., 01). Can also be comma-separated list: 01,02,05
  -n <session>        session ID (e.g., 1, 2, or none)
  -o                  Overwrite existing output
  <project root>      directory to output BIDSified data to
  <sourcedata>        directory containing to be converted data
  --lines             flag to tell we're dealing with a line-scanning session. By default 'regular',
                      which means standard whole-brain acquisitions.
  --inv               add individual inversion files from anatomies in 'anat' folder
  --dcm_fix           Extremely large par/rec's cannot be converted with 'dcm2niix'. Normal fMRI 
                      sessions are converted using 'call_pydcm2niix', but this flag points it to 'call
                      _dcm2niix', the same that is used for line-scanning sessions. It pipes the output 
                      from dcm2niix to a log file to monitor 'Catastrophic errors'. It then tries to 
                      convert these with 'parrec2nii', which comes with the python pacakge 'nibabel'.
  --take-avg-tr       Take the average over all TRs from the par file, rather than the first in the
                      sequence of TRs 

Example:
  spinoza_scanner2bids /path/to/project_root /path/to/your/project/sourcedata     # regular
  spinoza_scanner2bids -n 1/path/to/project_root /path/to/your/project/sourcedata # regular|ses-1
  spinoza_scanner2bids (shows this help text)                                     # help
  spinoza_scanner2bids --lines -n 2 DIR_DATA_HOME DIR_DATA_SOURCE                 # lines|ses-2

Notes:
  Assumes the following data structure:
  PROJECT
  └── sourcedata
      └── sub-001
          └── ses-1
              ├── task
              └── DICOMs/PARRECs
              
  Converts to:
  PROJECT
  └── sub-001
      └── ses-1
          ├── anat
          ├── func
          ├── fmap
          └── phase

---------------------------------------------------------------------------------------------------------

EOF
    exit 1
}

#---------------------------------------------------------------------------------------------------------
# Deal with arguments

# Check for subject & session flags
OW=0
SES_TYPE="regular"
ADD_INV=0
DCM_FIX=0
prot_flag=""
while getopts :-:os:n: argument
do
  case ${argument} in
    -)
      case "${OPTARG}" in
        lines)
          SES_TYPE="lines"
          ;;
        inv)
          ADD_INV=1
          ;;       
        dcm_fix)
          DCM_FIX=1
          SES_TYPE="lines"
          ;;  
        take-avg-tr)
          prot_flag="--take-avg-tr"
          ;;                       
        *)
          if [ "$OPTERR" = 1 ] && [ "${optspec:0:1}" != ":" ]; then
            echo "Unknown option --${OPTARG}, did you mean \"--lines\"?"
            exit 1
          fi
          ;;  
      esac;;    
    s)  sub=${OPTARG}
          ;;
    n)  ses=${OPTARG}
          ;;     
    o)  OW=1
          ;;                            
  esac
done

if [[ $# -lt 2 ]] ; then
  Usage >&2
  exit 1
fi

PROJECT_ROOT=${@:$OPTIND:1}
SOURCEDATA=${@:$OPTIND+1:1}

if [[ -z ${sub} ]]; then
  # loop through subjects
  search="${SOURCEDATA}/${SUBJECT_PREFIX}*"
else
  # read specified subjects into array
  IFS=', ' read -r -a search <<< "${sub}"
  search=${search[@]}
  unset IFS
fi

# 'import' some bash functions
source call_bashhelper

#-----------------------------------------------------------------------------
# Start clock
#-----------------------------------------------------------------------------
echo
echo "==================================================================================================="
printf "Convert raw data to nifti using dcm2niix/parrec2nii\n"
start=`date +%s`
start_date=`date`

printf "Started at ${start_date}\n"
echo "==================================================================================================="

#-----------------------------------------------------------------------------
# Run it
for subID in ${search}; do

  # collect subject name
  if [[ ! -z ${sub} ]]; then
    sub_name=${SUBJECT_PREFIX}${subID}
  else
    sub_name=$(basename ${subID})
  fi


  if [[ ! -z ${ses} ]]; then
    nr=`echo ${ses} | sed -e 's/^[[:space:]]*//'`
    base_path=${sub_name}/ses-${nr}
    base=${sub_name}_ses-${nr}
    msg="${sub_name} ses-${ses}: already processed"
  else
    base_path=${sub_name}
    base=${sub_name}
    msg="${sub_name}: already processed"
  fi  

  input_dir=${SOURCEDATA}/${base_path}
  output_dir=${input_dir}/nifti
  bids_dir=${PROJECT_ROOT}/${base_path}

  if [[ ${OW} -eq 1 ]]; then
    rm -r ${bids_dir}/* 2>/dev/null
  fi

  if [[ ${SES_TYPE} == "regular" ]]; then

    if [[ -d ${bids_dir}/anat && -d ${bids_dir}/func ]]; then
      nr_anat=`ls -l ${bids_dir}/anat | grep "total" | cut -d' ' -f2`
      nr_func=`ls -l ${bids_dir}/func | grep "total" | cut -d' ' -f2`
      if [ ${nr_anat} -ne 0 ] && [ ${nr_func} -ne 0 ]; then
        echo "${msg}; use \"master -m 02 -o\" to overwrite"
        echo " anat = ${nr_anat} | func = ${nr_func}"
        continue
      fi
    fi

    if [[ ! -d ${input_dir} ]]; then
      echo "${sub_name}: \"${input_dir}\" does not exist"
      continue
    else

      echo
      echo "**************************************** Processing ${sub_name} ***************************************"
      
      # We're dealing with session-1, the anatomical and pRF-mapping part, so we'll use FromScannerToBIDS.py/call_dcm2niix.py
      echo "Regular scan session (whole-brain data); using call_pydcm2niix"
      call_pydcm2niix ${input_dir} True False 2019

      echo "Reorienting images to LPI (conform fMRIPrep)"
      # for convenience, reorient all files to RAS+ (used by nibabel & fMRIprep)
      files=`find ${bids_dir} -type f -name "*.nii.gz"`
      for f in ${files[@]}; do
        val=`fslval ${f} qform_xorient`
        if [ ${val} != "Left-to-Right" ]; then
          call_reorient -i ${f} -c nb
        fi
      done

    fi

  elif [[ ${SES_TYPE} == "lines" ]]; then

    # check if input directory exists
    if [[ ! -d ${input_dir} ]]; then
      echo "${sub_name}: could not find input directory \"${input_dir}\""
      continue
    else

      if [[ ! -d ${bids_dir}/anat || ! -d ${bids_dir}/func ]]; then

        if [[ ${DCM_FIX} -eq 1 ]]; then
          intro_txt="Regular session, but with call_parrec2nii fix for big PAR/REC files"
        else
          intro_txt="Line-scanning session; using call_dcm2niix"
        fi

        echo
        echo "**************************************** Processing ${sub_name} ***************************************"
        echo ${intro_txt}

        if [[ ! -d ${bids_dir}/anat ]]; then
          mkdir -p ${bids_dir}/anat
        fi

        if [[ ! -d ${bids_dir}/func ]]; then
          mkdir -p ${bids_dir}/func
        fi

        #-------------------------------------------------------------------------------------------------------------------------------
        # PARREC TO NIFTI
        if [[ -d ${output_dir} ]]; then
          echo "Directory exists, skipping conversion."
        else
          echo "Converting files to nifti-format"
          call_dcm2niix ${prot_flag} -i ${input_dir} -o ${output_dir}
        fi

        echo "BIDSifying data .."

        #-------------------------------------------------------------------------------------------------------------------------------
        # NIFTI TO BIDS

        ## Low resolution anatomical scan
        if [[ ${DCM_FIX} -eq 0 ]]; then
          anat_lowres=`find "${input_dir}/planning/nifti" -type f \( -name "*real*" -and -name "*t10*" -and -name "*.nii.gz" \) 2>/dev/null`
          anat_t1map=`find "${input_dir}/planning/nifti" -type f \( -name "*real*" -and -name "*t29*" -and -name "*.nii.gz" \) 2>/dev/null`
          if [[ ! -f ${bids_dir}/anat/${base}_acq-MP2RAGE_T1w.nii.gz ]]; then
            if [[ -f ${anat_lowres} && -f ${anat_t1map} ]]; then

              min=`fslstats ${anat_lowres} -R | awk '{print $1}'`
              if [[ ${min} != "0.000000" ]]; then
                echo " Rescaling lowres MP2RAGE-file"
                call_maskmp2rage ${anat_lowres} ${anat_t1map} ${anat_lowres}
              fi

              echo " Relocating lowres MP2RAGE-file as ${base}_acq-MP2RAGE_T1w.nii.gz"
              cp ${anat_lowres} ${bids_dir}/anat/${base}_acq-MP2RAGE_T1w.nii.gz
              cp $(dirname ${anat_lowres})/$(basename ${anat_lowres} .nii.gz).json ${bids_dir}/anat/${base}_acq-MP2RAGE_T1w.json
            fi

          else
            echo " low resolution MP2RAGE exists"
          fi
        fi

        if [[ ${ADD_INV} -eq 1 ]] || [[ ${DCM_FIX} -eq 1 ]]; then
          inv_img=`find "${output_dir}" -type f \( -name "*T1w_*" -and -name "*_t10*" -or -name "*_t29*" -or -name "*_t30*" \) 2>/dev/null`
          IFS=$'\n' invs=($(sort <<<"${inv_img[*]}"))
          unset IFS

          for ff in ${invs[@]}; do
            if [[ ${ff} == *"_ph_"* ]]; then
              rec_tag="part-phase"
            else
              rec_tag="part-mag"
            fi

            if [[ ${ff} == *"t10"* ]]; then
              inv_tag="inv-1"
            else
              inv_tag="inv-2"
            fi

            ext=`fetch_extension ${ff}`
            if [[ ${ext} == "gz" ]]; then
              ext="nii.gz"
            fi

            out_fn=${bids_dir}/anat/${base}_acq-${DATA}_${inv_tag}_${rec_tag}.${ext}
            if [[ ! -f ${out_fn} ]]; then
              cp ${ff} ${out_fn}
            fi

          done

          # find T2s or FLAIR
          for qq in "T2w" "FLAIR"; do
            img=`find "${output_dir}" -type f \( -name "*${qq}.nii.gz" \) 2>/dev/null`
            if [ ! -z ${img} ]; then
              acq=`get_id ${img} acq`
              if [[ ! -z ${acq} ]]; then
                acq_tag="_acq-${acq}"
              else
                acq_tag=""
              fi
              out_fn=${bids_dir}/anat/${base}${acq_tag}_${qq}.nii.gz
              cp ${img} ${out_fn} 2>/dev/null

              json_fn=$(dirname ${img})/$(basename ${img} .nii.gz).json
              if [ -f ${json_fn} ]; then
                cp ${json_fn} $(dirname ${out_fn})/$(basename ${out_fn} .nii.gz).json
              fi
            fi
          done
        fi

        if [[ ${DCM_FIX} -eq 0 ]]; then
          ## Multi-slice files
          motion_img=`find "${output_dir}" -type f \( -name "*motion*" -and -name "*.nii.gz" \) 2>/dev/null`
          IFS=$'\n' motion_img=($(sort <<<"${motion_img[*]}"))
          unset IFS    

          echo " Relocating multi-slice file (${#motion_img[@]})"
          for i in ${motion_img[@]}; do
            
            run=`get_id ${i} motion`
            if [[ -z ${run} ]]; then
              run=${i}
            fi

            fname=${bids_dir}/anat/${base}_acq-MP2RAGE_rec-motion${run}.nii.gz
            if [[ ! -f ${fname} ]]; then
              if [[ -f ${motion_img} ]]; then
                echo "  renaming to $(basename ${fname})"
                cp ${motion_img} ${fname}
                cp $(dirname ${motion_img})/$(basename ${motion_img} .nii.gz).json $(dirname ${fname})/$(basename ${fname} .nii.gz).json
              else
                echo "  WARNING: apparently found ${n_motion} motion file(s), but cannot find file with \"motion${run}\" and \"*.nii.gz\""
              fi
            else
              echo "  ${base}_acq-9slice_run-${run}_T1w.nii.gz exists"
            fi
          done


          ## Single-slice
          slice_img=`find "${output_dir}" -type f \( -name "*1slice*" -and -not -name "*space*" -and -name "*anat*" -and -name "*.nii.gz" \) 2>/dev/null`
          
          # sort array (https://stackoverflow.com/questions/7442417/how-to-sort-an-array-in-bash)
          IFS=$'\n' slice_img=($(sort <<<"${slice_img[*]}"))
          unset IFS   

          # add counter in case run-X does not occur in file     
          count=0
          if [[ ! -z ${slice_img} ]]; then
            
            echo " Found 1slice-files"

            for slice in ${slice_img[@]}; do
              ((count++))

              # fetch run
              run=`run_id ${slice}`
              if [[ ${run} -eq 0 ]]; then
                run=${count}
              fi     
            
              bids_slice=${bids_dir}/anat/${base}_acq-1slice_run-${run}_T1w.nii.gz
              if [[ ! -f ${bids_slice} ]]; then
                if [[ -f ${slice} ]]; then
                  echo "  renaming to $(basename ${bids_slice})"
                  cp ${slice} ${bids_slice}
                  cp $(dirname ${slice})/$(basename ${slice} .nii.gz).json $(dirname ${bids_slice})/$(basename ${bids_slice} .nii.gz).json
                fi
              else
                echo "  $(basename ${bids_slice}) exists"
              fi

            done
          
          else
            echo "  WARNING: no \"1slice\"-files were found in ${output_dir}"
          fi

          ## bold files
          bold_files=`find "${input_dir}" -type f \( -name "*bold_*" -and -name "*.lab" \) 2>/dev/null`

          # sort array (https://stackoverflow.com/questions/7442417/how-to-sort-an-array-in-bash)
          IFS=$'\n' bold_files=($(sort <<<"${bold_files[*]}"))
          unset IFS    

          count=0
          if [[ ! -z ${bold_files} ]]; then

            echo " Found raw bold-files (*.lab)"
    
            # get foldover direction
            info_file=`find "${DIR_DATA_DERIV}/pycortex/${sub_name}" -type f \( -name "*desc-info*" -and -name "*.csv" \) 2>/dev/null`
            if [[ -f ${info_file} ]]; then
              fold=`grep -A0 "foldover" ${info_file} | cut -d',' -f3`
            else
              # default to FH foldover
              fold="FH"
            fi
            echo "  foldover is set to: ${fold}"

            # get foldover direction
            if [[ ! -z ${ses} ]]; then
              md=`find $(dirname ${input_dir}) -type f \( -name "*ses-${nr}*" -and -name "*.md" \) 2>/dev/null`
            else
              md=`find $(dirname ${input_dir}) -type f \( -name "*ses-${nr}*" -and -name "*.md" \) 2>/dev/null`
            fi

            # check for multiple files; take last one if more than one are found
            cnt=0
            for ii in ${md[@]}; do ((cnt++)); done
            if [[ ${cnt} -gt 1 ]]; then
              md=${md[cnt]}
            fi

            shift=0
            if [[ -f ${md} ]]; then
              shift=`grep -A0 "shift:" ${md} | cut -d":" -f2`
            fi
            echo "  shift is set to: ${shift}mm"
            
            # use run-1 as template
            slice_img=`find "${bids_dir}/anat" -type f \( -name "${base}*" -and -name "*1slice*" -and -name "*run-1*" -and -name "*.nii.gz" \) 2>/dev/null`
            for bold in ${bold_files[@]}; do
              ((count++))

              # fetch task
              task=`task_id ${bold}`
              if [[ ${task} == "prf" ]]; then
                task="pRF"
              elif [[ ${task} == "sr" ]]; then
                task="SR"
              fi

              # fetch run
              run=`run_id ${bold}`
              if [[ ${run} -eq 0 ]]; then
                run=${count}
              fi   

              line_img=${bids_dir}/func/${base}_task-${task}_run-${run}_bold.nii.gz
              if [[ -f ${slice_img} ]]; then
                if [[ ! -f ${line_img} ]]; then

                  call_createline \
                    -i ${slice_img} \
                    -o ${line_img} \
                    --width 16 \
                    --${fold,,} \
                    --shift ${shift}

                  if [[ $? != 0 ]]; then
                    echo
                    echo "---------------------------------------------------------------------------------------------------"
                    echo "ERROR in `basename ${0}`: call_createline exited with non-zero status"
                    exit 1
                  fi

                  echo "  wrote `basename ${line_img}`"
                else
                  echo "  `basename ${line_img}` exists"
                fi
              else
                echo "  WARNING: could not find file with [\"acq-1slice\" and \"run-1\"] in \"${bids_dir}/anat\""
              fi

            done
          
          else
            echo "  WARNING: no \"bold*.lab\"-files were found in ${input_dir}"
          fi
        fi

        # check for more whole-brainy stuff
        if [[ ${DCM_FIX} -eq 0 ]]; then
          b_files=`find "${input_dir}" -type f \( -name "*acq-3DEPI*" -and -name "*bold.nii.gz" \) 2>/dev/null`
        else
          b_files=`find "${input_dir}" -type f \( -name "*bold.nii.gz" \) 2>/dev/null`
        fi

        # sort array (https://stackoverflow.com/questions/7442417/how-to-sort-an-array-in-bash)
        IFS=$'\n' bold_files=($(sort <<<"${b_files[*]}"))
        unset IFS

        count=0
        mb_warning=0
        pe_warning=0
        if [[ ! -z ${bold_files[@]} ]]; then
          echo " Found BOLD file(s)"

          for bold in ${bold_files[@]}; do

            echo $bold
            # fetch run
            run=`run_id ${bold}`
            if [[ ${run} -eq 0 ]]; then
              run=${count}
            fi 

            func=${bold}
            fmap=$(dirname ${bold})/$(basename ${bold} _bold.nii.gz)_epi.nii.gz
            phase=$(dirname ${bold})/$(basename ${bold} .nii.gz)_ph.nii.gz
            
            task=`task_id ${bold}`
            acq=`get_id ${bold} acq`

            desc=""
            if [[ ${bold} == *"desc"* ]]; then
              desc=`get_id ${bold} desc`
            fi

            # rename 'bold', 'epi', and 'phase'
            for ext in "_bold.nii.gz" "_epi.nii.gz" "_bold_ph.nii.gz"; do

              if [[ ${ext} == "_bold.nii.gz" ]]; then
                orig=${func}
                image="func"
              elif [[ ${ext} == "_epi.nii.gz" ]]; then
                orig=${fmap}
                image="fmap"
              elif [[ ${ext} == "_bold_ph.nii.gz" ]]; then
                orig=${phase}
                image="phase"
              fi

              # check if we got acquisition; if we also got desc, add it to acq, as fMRIprep doesn't like the desc- field
              if [[ ! -z ${acq} ]]; then
                add_acq="_acq-${acq}"
                if [[ ! -z ${desc} ]]; then
                  add_acq+="${desc}"
                fi
              else
                add_acq=""
                if [[ ! -z ${desc} ]]; then
                  add_acq="_acq-${desc}"
                fi
              fi              

              # compile filename
              ff=${bids_dir}/${image}/${base}_task-${task}_run-${run}${add_acq}${ext}
              if [[ ! -f ${ff} ]]; then
                if [[ ! -d ${ff} ]]; then
                  mkdir -p $(dirname ${ff})
                fi

                if [[ -f ${orig} ]]; then
                  echo "  renaming ${image}-file to `basename ${ff}`"
                  cp ${orig} ${ff}

                  # also reorient to LPI because dcm2niix does AIL, parrec2nii does RPI woohoo.. Fun.
                  call_reorient -i ${ff}

                  json_file=$(dirname ${orig})/$(basename ${orig} .nii.gz).json
                  if [ -f ${json_file} ]; then
                    json_bids=$(dirname ${ff})/$(basename ${ff} .nii.gz).json
                    cp ${json_file} ${json_bids}

                    # check if json file has IntendedFor
                    intended_for=`cat ${json_bids} | grep "IntendedFor"`
                    if [[ -z ${intended_for} ]]; then
                      if [[ ${image} == "fmap" ]]; then

                        base_path=""
                        if [[ $(basename ${json_bids}) == *"ses"* ]]; then
                          ses_nr=$(basename ${json_bids} | cut -d"_" -f2)
                          base_path+="${ses_nr}"
                        fi

                        # add IntendedFor
                        call_json ${json_bids} IntendedFor ${base_path}/func/$(basename ${json_bids} _epi.json)_bold.nii.gz
                      fi
                    fi

                    # add other information that call_parrec2nii would've added by reading the ParFile key that should've been added by call_dcm2niix
                    par_f=`read_json ${json_bids} ParFile`
                    if [[ ! -z ${par_f} ]]; then
                      echo "  Storing information from `basename ${par_f}` in json file"
                      pars_for_json --merge ${par_f} ${json_bids}

                      # check if we can add slicetimings
                      if [[ ${image} != "phase" ]]; then
                        scan_mode=`read_par ${par_f} "Scan mode"`

                        if [[ ${scan_mode} != "3D" ]]; then
                          mb_factor=`read_json ${json_bids} MultiBandAccelerationFactor`
                          if [[ -z ${mb_factor} ]]; then
                            mb_factor=3
                            mb_warning=1
                            echo "  WARNING: defaulting to multiband factor 3 for slice-timings, please check if this is correct!"
                          fi

                          tr=`read_json ${json_bids} RepetitionTime`
                          n_slices=`read_par ${par_f} "Max. number of slices/locations"`
                          call_slicetiming ${json_bids} ${tr} ${n_slices} ${mb_factor}

                          if [[ $? -ne 0 ]]; then
                            echo "ERROR in `basename ${0}`: call_slicetiming exited with non-zero code"
                            exit 1
                          fi
                        fi
                      fi
                    fi

                    # check PhaseEncodingDirection
                    phase_enc_dir=`cat ${json_bids} | grep "PhaseEncodingDirection"`
                    if [[ -z ${phase_enc_dir} ]]; then
                      if [[ ${image} == "fmap" ]]; then
                        ph_dir="j"
                      elif [[ ${image} == "func" ]]; then
                        ph_dir="j-"
                      else
                        ph_dir=""
                      fi

                      if [[ ! -z ${ph_dir} ]]; then
                        pe_warning=1
                        echo "  WARNING: assuming PE-direction for ${image^^}=\"${ph_dir}\", please check if this is correct!"
                        call_json ${json_bids} PhaseEncodingDirection ${ph_dir}
                      fi
                    fi
                  fi
                fi
              else
                echo "  $(basename ${ff}) exists"
              fi

            done

          done

          # check for physio files
          phys=`find "${input_dir}" -type f \( -name "SCANPHYS*" -and -name "*bold_*.log" \) 2>/dev/null`

          # sort array
          IFS=$'\n' phys=($(sort <<<"${phys[*]}"))
          unset IFS
          if [[ ! -z ${phys} ]]; then

            echo " Found physio file(s)"
            if [[ ! -d ${bids_dir}/physio ]]; then
              mkdir -p ${bids_dir}/physio
            fi            

            count=0
            for file in ${phys[@]}; do
              
              # add counter in case file does not contain run-X id
              ((count++))

              # fetch task
              task=`task_id ${file}`
              if [[ ${task} == "prf" ]]; then
                task="pRF"
              else
                task=${task^^}
              fi

              # fetch run
              run=`run_id ${file}`
              if [[ ${run} -eq 0 ]]; then
                run=${count}
              fi              

              bids_phys=${bids_dir}/physio/${base}_task-${task}_run-${run}_physio.log
              if [[ ! -f ${bids_phys} ]]; then
                echo "  renaming physio-file to `basename ${bids_phys}`"
                cp ${file} ${bids_phys}
              fi              
            done
          fi
          echo " Done"
        fi
        echo "Done"
      else
        echo "${msg}; use \"master -m 02 -o\" to overwrite"
      fi
    fi
  else
    echo "Invalid session-type \"${SES_TYPE}\". Must be 'regular' or 'lines'"
    continue
  fi

done

#---------------------------------------------------------------------------------------------------------
# make dataset_description file if it doesn't exist. User enters a line for the description

if [[ ! -f ${DIR_DATA_HOME}/dataset_description.json ]]; then

  cd ${DIR_DATA_HOME}
  echo "enter the name of the project and press [ENTER]: " && read DESCRIPTION

  (
  echo "{"
  echo "    \"Name\": \"${DESCRIPTION}\","
  echo "    \"BIDSVersion\": \"1.2.2\","
  echo "    \"License\": \"RECOMMENDED. What license is this dataset distributed under?. The use of license name abbreviations is suggested for specifying a license\","
  echo "    \"Authors\": ["
  echo "        \"G.J. Heij\""
  echo "    ],"
  echo "    \"Acknowledgements\": \"OPTIONAL. List of individuals who contributed to the creation/curation of the dataset\","
  echo "    \"HowToAcknowledge\": \"OPTIONAL. Instructions how researchers using this dataset should acknowledge the original authors. This field can also be used to define a publication that should be cited in publications that use the dataset\","
  echo "    \"Funding\": ["
  echo "        \"OPTIONAL. List of sources of funding (grant numbers)\""
  echo "    ],"
  echo "    \"ReferencesAndLinks\": ["
  echo "        \"OPTIONAL. List of references to publication that contain information on the dataset, or links\","
  echo "        \"https://github.com/Donders-Institute/bidscoin\""
  echo "    ],"
  echo "    \"DatasetDOI\": \"OPTIONAL. The Document Object Identifier of the dataset (not the corresponding paper)\""
  echo "}"
  ) > dataset_description.json

  cd -

fi

if [[ ${warning} -eq 1 ]]; then
  echo
  echo "---------------------------------------------------------------------------------------------------"
  echo "WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING"
  echo ""
  if [[ ${pe_warning} -eq 1 ]]; then
    echo "I assumed the PhaseEncoding direction in the FMAP/FUNC-folder; please make sure this is correct!"
  fi

  if [[ ${mb_warning} -eq 1 ]]; then
    echo "I might have assumed information about the acceleration factor to get the slice timings.."
  fi

  echo "Please check that this is correct!"
  echo "---------------------------------------------------------------------------------------------------"
fi

#-----------------------------------------------------------------------------
# Calculate time spent using 'let'
echo
echo "---------------------------------------------------------------------------------------------------"
end=`date +%s`
end_date=`date`
printf "Done at ${end_date}\n"

let deltatime=end-start
let hours=deltatime/3600
let minutes=(deltatime/60)%60
let seconds=deltatime%60
printf "Time spent: %d:%02d:%02d\n" ${hours} ${minutes} ${seconds}
echo "---------------------------------------------------------------------------------------------------"
echo
