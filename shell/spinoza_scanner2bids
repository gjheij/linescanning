#!/usr/bin/env bash

#---------------------------------------------------------------------------------------------------------
# check if there's is a setup file containing the major paths and source it if it exists
call_loadsetup

#---------------------------------------------------------------------------------------------------------
# Create help text
function Usage {
    cat <<EOF

---------------------------------------------------------------------------------------------------
spinoza_scanner2bids

convert raw data from the scanner to nifti format. Depending on which session we're analyzing, we'll
use either call_dcm2niix.py (session 1 - which is FromScannerToBIDS.py from M. Aquil) which can deal
nicely with the anatomical and functional stuff or call_dcm2niix.sh, which is more specific for the
line scanning stuff.

Input options:
  <project root>    directory to output BIDSified data to
  <sourcedata>      directory containing to be converted data
  <session number>  session number to be converted (ses-1 and ses-${SES_NR} require different types of con-
                    version, whereas session 1 can be converted with call_dcm2niix.py, we need to
                    use a custom conversion for session 2 to get it somewhat in BIDS-format)

Example:
  spinoza_scanner2bids /path/to/project_root /path/to/your/project/sourcedata 1
  spinoza_scanner2bids (shows this help text)
  spinoza_scanner2bids $DIR_DATA_HOME $DIR_DATA_SOURCE 1

Notes:
  Assumes that you ran spinoza_newBIDSsession with the following data structure:
  > PROJECT
    > sourcedata
      > ${PREFIX}001
        > ses-1
          > .PAR
          > .REC

  Converts to:
  > PROJECT
    > ${PREFIX}001
      > ses-x
        > anat
        > func
        > fmap

---------------------------------------------------------------------------------------------------------

EOF
    exit 1
}

#---------------------------------------------------------------------------------------------------------
# Deal with arguments

# Check for subject & session flags
while getopts os:n: argument
do
    case ${argument} in
      s)  sub=${OPTARG}
            ;;
      n)  prf_ses=${OPTARG}
            ;;                  
    esac
done

if [[ $# -lt 2 ]] ; then
  Usage >&2
  exit 1
fi

PROJECT_ROOT=${@:$OPTIND:1}
SOURCEDATA=${@:$OPTIND+1:1}
SES_NR=${@:$OPTIND+2:1}

if [[ -z ${sub} ]]; then
  # loop through subjects
  search="${SOURCEDATA}/${PREFIX}*"
else
  # do for 1 subject
  search="${SOURCEDATA}/${PREFIX}${sub}"
fi

# if we're dealing with a pRF session, we can specify the number with the -n flag (-x flag in master command)
if [[ ${SES_NR,,} == "prf" ]]; then
  if [[ -z ${prf_ses} ]]; then
    txt="pRF-session was selected, but no session ID was provided; assuming \"ses-1\""
    ses_id=1
  else
    ses_id=${prf_ses}
    txt="pRF-session was selected with ses-ID: \"ses-${ses_id}\""
  fi
else
  ses_id=${SES_NR}
fi

if [[ "${@}" == *"-o"* ]]; then
  OW=1
else
  OW=0
fi

# 'import' some bash functions
source call_bashhelper

#-----------------------------------------------------------------------------
# Start clock
#-----------------------------------------------------------------------------
echo
echo "==================================================================================================="
printf "Convert raw data to nifti using dcm2niix\n"
start=`date +%s`
start_date=`date`

printf "Started at ${start_date}\n"
echo "==================================================================================================="


#-----------------------------------------------------------------------------
# Run it
for dir in ${search}; do

  inputdir=${SOURCEDATA}/$(basename ${dir})/ses-${ses_id}
  outputdir=${inputdir}/nifti
  bidsdir=${PROJECT_ROOT}/$(basename ${dir})/ses-${ses_id}

  if [[ ${OW} -eq 1 ]]; then
    rm -r ${bidsdir}/* 2>/dev/null
  fi

  if [[ ${SES_NR} == "prf" ]]; then

    if [[ -d ${bidsdir}/anat && -d ${bidsdir}/func ]]; then
      nr_anat=`ls -l ${bidsdir}/anat | grep "total" | cut -d' ' -f2`
      nr_func=`ls -l ${bidsdir}/func | grep "total" | cut -d' ' -f2`
      if [ ${nr_anat} -ne 0 ] && [ ${nr_func} -ne 0 ]; then
        echo "`basename ${dir}` ses-${ses_id}: already processed; use \"master -m 02 -o\" to overwrite"
        echo " anat = ${nr_anat} | func = ${nr_func}"
        continue
      fi
    fi

    if [[ ! -d ${inputdir} ]]; then

      echo "Could not find input directory containing PARREC-files.."
      continue

    else

      echo
      echo "**************************************** Processing `basename ${dir}` ***************************************"
      echo ${txt}
      
      # We're dealing with session-1, the anatomical and pRF-mapping part, so we'll use FromScannerToBIDS.py/call_dcm2niix.py
      echo "Processing session ${SES_NR} - anatomical and PRF-session; using call_dcm2niix.py"
      call_pydcm2niix ${inputdir} True False 2019

      # for convenience, reorient all files to RAS+ (used by nibabel & fMRIprep)
      files=`find ${bidsdir} -type f -name "*.nii.gz"`
      for f in ${files[@]}; do
        val=`fslval ${f} qform_xorient`
        if [ ${val} != "Left-to-Right" ]; then
          call_reorient -i ${f} -c nb
        fi
      done

    fi

  elif [[ ${SES_NR} != "prf" ]]; then

    # echo $inputdir
    # echo $outputdir

    # We're dealing with session-2, the line scanning part, so we'll use call_dcm2niix.sh
    if [[ ! -d ${inputdir} ]]; then

      echo "`basename ${dir}` ses-${ses_id}: not yet performed"
      continue

    else

      if [[ ! -d ${bidsdir}/anat && ! -d ${bidsdir}/func ]]; then

        echo
        echo "**************************************** Processing `basename ${dir}` ***************************************"
        echo "Processing session ${ses_id} - line-scanning session; using call_dcm2niix"

        if [[ ! -d ${bidsdir}/anat ]]; then
          mkdir -p ${bidsdir}/anat
        fi

        if [[ ! -d ${bidsdir}/func ]]; then
          mkdir -p ${bidsdir}/func
        fi

        #-------------------------------------------------------------------------------------------------------------------------------
        # PARREC TO NIFTI
        if [[ -d ${outputdir} ]]; then
          echo "Directory exists, skipping conversion."
        else
          echo "Converting files to nifti-format"
          call_dcm2niix -i ${inputdir} -o ${outputdir}
        fi

        echo "BIDSifying data .."

        #-------------------------------------------------------------------------------------------------------------------------------
        # NIFTI TO BIDS

        ## Low resolution anatomical scan
        anat_lowres=`find "${inputdir}/planning/nifti" -type f \( -name "*real*" -and -name "*t10*" -and -name "*.nii.gz" \) 2>/dev/null`
        anat_t1map=`find "${inputdir}/planning/nifti" -type f \( -name "*real*" -and -name "*t29*" -and -name "*.nii.gz" \) 2>/dev/null`
        if [[ ! -f ${bidsdir}/anat/$(basename ${dir})_ses-${SES_NR}_acq-MP2RAGE_T1w.nii.gz ]]; then
          if [[ -f ${anat_lowres} && -f ${anat_t1map} ]]; then

            min=`fslstats ${anat_lowres} -R | awk '{print $1}'`
            if [[ ${min} != "0.000000" ]]; then
              echo " Rescaling lowres MP2RAGE-file"
              call_maskmp2rage ${anat_lowres} ${anat_t1map} ${anat_lowres}
            fi

            echo " Relocating lowres MP2RAGE-file as $(basename ${dir})_ses-${ses_id}_acq-MP2RAGE_T1w.nii.gz"
            cp ${anat_lowres} ${bidsdir}/anat/$(basename ${dir})_ses-${ses_id}_acq-MP2RAGE_T1w.nii.gz
            cp $(dirname ${anat_lowres})/$(basename ${anat_lowres} .nii.gz).json ${bidsdir}/anat/$(basename ${dir})_ses-${ses_id}_acq-MP2RAGE_T1w.json
          fi

        else
          echo " low resolution MP2RAGE exists"
        fi

        ## Multi-slice files
        n_motion=`echo ${outputdir}/*motion*.nii.gz | wc -w`
        echo " Relocating multi-slice file (${n_motion})"
        for i in `seq 1 ${n_motion}`; do
          motion_img=`find "${outputdir}" -type f \( -name "*motion${i}*" -and -name "*.nii.gz" \) 2>/dev/null`
          fname=${bidsdir}/anat/$(basename ${dir})_ses-${ses_id}_acq-MP2RAGE_rec-motion${i}.nii.gz
          if [[ ! -f ${fname} ]]; then
            if [[ -f ${motion_img} ]]; then
              echo "  renaming to $(basename ${fname})"
              cp ${motion_img} ${fname}
              cp $(dirname ${motion_img})/$(basename ${motion_img} .nii.gz).json $(dirname ${fname})/$(basename ${fname} .nii.gz).json
            else
              echo " WARNING: apparently found ${n_motion} motion file(s), but cannot find file with \"motion${i}\" and \"*.nii.gz\""
            fi
          else
            echo "  $(basename ${dir})_ses-${ses_id}_acq-9slice_run-${i}_T1w.nii.gz exists"
          fi
        done


        ## Single-slice
        slice_img=`find "${outputdir}" -type f \( -name "*1slice*" -and -not -name "*space*" -and -name "*anat*" -and -name "*.nii.gz" \) 2>/dev/null`
        
        # sort array (https://stackoverflow.com/questions/7442417/how-to-sort-an-array-in-bash)
        IFS=$'\n' slice_img=($(sort <<<"${slice_img[*]}"))
        unset IFS   

        # add counter in case run-X does not occur in file     
        count=0
        if [[ ! -z ${slice_img} ]]; then
          
          echo " Found 1slice-files"

          for slice in ${slice_img[@]}; do
            ((count++))

            # fetch run
            run=`run_id ${slice}`
            if [[ ${run} -eq 0 ]]; then
              run=${count}
            fi     
          
            bids_slice=${bidsdir}/anat/$(basename ${dir})_ses-${ses_id}_acq-1slice_run-${run}_T1w.nii.gz
            if [[ ! -f ${bids_slice} ]]; then
              if [[ -f ${slice} ]]; then
                echo "  renaming to $(basename ${bids_slice})"
                cp ${slice} ${bids_slice}
                cp $(dirname ${slice})/$(basename ${slice} .nii.gz).json $(dirname ${bids_slice})/$(basename ${bids_slice} .nii.gz).json
              fi
            else
              echo "  $(basename ${bids_slice}) exists"
            fi

          done
        
        else
          echo "  WARNING: no \"1slice\"-files were found in ${outputdir}"
        fi

        ## bold files
        bold_files=`find "${inputdir}" -type f \( -name "*bold_*" -and -name "*.lab" \) 2>/dev/null`

        # sort array (https://stackoverflow.com/questions/7442417/how-to-sort-an-array-in-bash)
        IFS=$'\n' slice_img=($(sort <<<"${slice_img[*]}"))
        unset IFS    

        count=0
        if [[ ! -z ${bold_files} ]]; then

          echo " Found raw bold-files (*.lab)"
  
          # get foldover direction
          info_file=`find "${DIR_DATA_DERIV}/pycortex/$(basename ${dir})" -type f \( -name "*desc-info*" -and -name "*.csv" \) 2>/dev/null`
          if [[ -f ${info_file} ]]; then
            fold=`grep -A0 "foldover" ${info_file} | cut -d',' -f3`
          else
            # default to FH foldover
            fold="FH"
          fi

          echo "  foldover is set to: ${fold}"

          for bold in ${bold_files[@]}; do
            ((count++))

            # use run-1 as template
            slice_img=`find "${bidsdir}/anat" -type f \( -name "*1slice*" -and -name "*run-1*" -and -name "*.nii.gz" \) 2>/dev/null`
            
            # fetch task
            task=`task_id ${bold}`
            if [[ ${task} == "prf" ]]; then
              task="pRF"
            else
              task=${task^^}
            fi

            # fetch run
            run=`run_id ${bold}`
            if [[ ${run} -eq 0 ]]; then
              run=${count}
            fi   

            line_img=${bidsdir}/func/$(basename ${dir})_ses-${ses_id}_task-${task}_run-${run}_bold.nii.gz

            if [[ -f ${slice_img} ]]; then
              if [[ ! -f ${line_img} ]]; then
                call_createline "${slice_img}" "${line_img}" "16" "${fold}"

                if [[ $? != 0 ]]; then
                  echo
                  echo "---------------------------------------------------------------------------------------------------"
                  echo "ERROR in `basename ${0}`: call_createline exited with non-zero status"
                  exit 1
                fi

                echo "  wrote `basename ${line_img}`"
              else
                echo "  `basename ${line_img}` exists"
              fi
            else
              echo "  WARNING: could not find slice-img for \"1slice\" and \"run-1\""
            fi

          done
        
        else
          echo "  WARNING: no \"bold*.lab\"-files were found in ${inputdir}"
        fi

        # check if we also did partial 3DEPI stuff
        nr_epis=`echo ${outputdir}/*bold.nii.gz | wc -w`
        if [[ ${nr_epis} -gt 0 ]]; then
          echo " Found ${nr_epis} EPI file(s)"

          for i in `seq 1 ${nr_epis}`; do

            func=`find "${outputdir}" -type f \( -name "*acq-3DEPI*" -and -name "*run-${i}*" -and -name "*bold.nii.gz" \) 2>/dev/null`
            fmap=`find "${outputdir}" -type f \( -name "*acq-3DEPI*" -and -name "*run-${i}*" -and -name "*epi.nii.gz" \) 2>/dev/null`
            phase=`find "${outputdir}" -type f \( -name "*acq-3DEPI*" -and -name "*run-${i}*" -and -name "*bold_ph.nii.gz" \) 2>/dev/null`
            task=`task_id ${func}`

            # -acq needs to be after task to be compatible with fMRIprep
            tmp_dir=$(dirname ${outputdir})/func
            if [[ ! -d ${tmp_dir} ]]; then
              mkdir -p ${tmp_dir}
            fi

            fname=${tmp_dir}/$(basename ${dir})_ses-${ses_id}_task-${task}_run-${i}_acq-3DEPI
            bids_func=${fname}_bold.nii.gz
            if [[ ! -f ${bids_func} ]]; then
              if [[ -f ${func} ]]; then
                echo "  renaming func-file to `basename ${bids_func}`"
                cp ${func} ${bids_func}
                cp $(dirname ${func})/$(basename ${func} .nii.gz).json $(dirname ${bids_func})/$(basename ${bids_func} .nii.gz).json
              else
                echo "WARNING: found ${nr_epis} EPI-files, but could not find file with \"acq-3DEPI\", \"run-${i}\", and \"bold.nii.gz\""
              fi
            else
              echo "  $(basename ${bids_func}) exists"
            fi

            bids_func=${fname}_epi.nii.gz
            if [[ ! -f ${bids_epi} ]]; then
              if [[ -f ${fmap} ]]; then
                echo "  renaming epi-file to `basename ${bids_epi}`"
                cp ${fmap} ${bids_epi}
                cp $(dirname ${fmap})/$(basename ${fmap} .nii.gz).json $(dirname ${bids_epi})/$(basename ${bids_epi} .nii.gz).json
              fi
            fi

            bids_func=${fname}_bold_ph.nii.gz
            if [[ ! -f ${bids_epi} ]]; then
              if [[ -f ${fmap} ]]; then
                echo "  renaming phase-file to `basename ${bids_epi}`"
                cp ${fmap} ${bids_epi}
                cp $(dirname ${fmap})/$(basename ${fmap} .nii.gz).json $(dirname ${bids_epi})/$(basename ${bids_epi} .nii.gz).json
              fi
            fi            

            echo " These files should be treated with \"partial_preprocess.py\" in the pRFline-package"
            echo " See also: https://github.com/spinoza-centre/pRFline/tree/main/scripts"    

          done

          # check for physio files
          phys=`find "${inputdir}" -type f \( -name "SCANPHYS*" -and -name "*bold_*.log" \) 2>/dev/null`

          # sort array
          IFS=$'\n' phys=($(sort <<<"${phys[*]}"))
          unset IFS
          if [[ ! -z ${phys} ]]; then

            echo " Found physio file(s)"
            if [[ ! -d ${bidsdir}/physio ]]; then
              mkdir -p ${bidsdir}/physio
            fi            

            count=0
            for file in ${phys[@]}; do
              
              # add counter in case file does not contain run-X id
              ((count++))

              # fetch task
              task=`task_id ${file}`
              if [[ ${task} == "prf" ]]; then
                task="pRF"
              else
                task=${task^^}
              fi

              # fetch run
              run=`run_id ${file}`
              if [[ ${run} -eq 0 ]]; then
                run=${count}
              fi              

              bids_phys=${bidsdir}/physio/$(basename ${dir})_ses-${ses_id}_task-${task}_run-${run}_physio.log
              if [[ ! -f ${bids_phys} ]]; then
                echo "  renaming physio-file to `basename ${bids_phys}`"
                cp ${file} ${bids_phys}
              fi              
            done

          fi

          echo " Done"

        fi

        echo "Done"

      else

        echo "ses-${ses_id} of `basename ${dir}` already processed; use \"master -m 02 -o\" to overwrite"

      fi

    fi

  else

    echo "Session number is ${SES_NR}; not sure what to do with this.."
    continue

  fi

done

#---------------------------------------------------------------------------------------------------------
# make dataset_description file if it doesn't exist. User enters a line for the description

if [[ ! -f ${DIR_DATA_HOME}/dataset_description.json ]]; then

  cd ${DIR_DATA_HOME}
  echo "enter the name of the project and press [ENTER]: " && read DESCRIPTION

  (
  echo "{"
  echo "    \"Name\": \"${DESCRIPTION}\","
  echo "    \"BIDSVersion\": \"1.2.2\","
  echo "    \"License\": \"RECOMMENDED. What license is this dataset distributed under?. The use of license name abbreviations is suggested for specifying a license\","
  echo "    \"Authors\": ["
  echo "        \"G.J. Heij\""
  echo "    ],"
  echo "    \"Acknowledgements\": \"OPTIONAL. List of individuals who contributed to the creation/curation of the dataset\","
  echo "    \"HowToAcknowledge\": \"OPTIONAL. Instructions how researchers using this dataset should acknowledge the original authors. This field can also be used to define a publication that should be cited in publications that use the dataset\","
  echo "    \"Funding\": ["
  echo "        \"OPTIONAL. List of sources of funding (grant numbers)\""
  echo "    ],"
  echo "    \"ReferencesAndLinks\": ["
  echo "        \"OPTIONAL. List of references to publication that contain information on the dataset, or links\","
  echo "        \"https://github.com/Donders-Institute/bidscoin\""
  echo "    ],"
  echo "    \"DatasetDOI\": \"OPTIONAL. The Document Object Identifier of the dataset (not the corresponding paper)\""
  echo "}"
  ) > dataset_description.json

  cd -

fi

#-----------------------------------------------------------------------------
# Calculate time spent using 'let'
echo
echo "---------------------------------------------------------------------------------------------------"
end=`date +%s`
end_date=`date`
printf "Done at ${end_date}\n"

let deltatime=end-start
let hours=deltatime/3600
let minutes=(deltatime/60)%60
let seconds=deltatime%60
printf "Time spent: %d:%02d:%02d\n" ${hours} ${minutes} ${seconds}
echo "---------------------------------------------------------------------------------------------------"
echo
