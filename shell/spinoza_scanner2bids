#!/usr/bin/env bash

#---------------------------------------------------------------------------------------------------------
# check if there's is a setup file containing the major paths and source it if it exists
call_loadsetup

#---------------------------------------------------------------------------------------------------------
# Create help text
function Usage {
    cat <<EOF

---------------------------------------------------------------------------------------------------
spinoza_scanner2bids

convert raw data from the scanner to nifti format. Depending on which session we're analyzing, we'll
use either call_dcm2niix.py (session 1 - which is FromScannerToBIDS.py from M. Aquil) which can deal
nicely with the anatomical and functional stuff or call_dcm2niix.sh, which is more specific for the
line scanning stuff.

Input options:
  -s <subject>        subject ID (e.g., 01). Can also be comma-separated list: 01,02,05
  -n <session>        session ID (e.g., 1, 2, or none)
  -o                  Overwrite existing output
  <project root>      directory to output BIDSified data to
  <sourcedata>        directory containing to be converted data
  --lines             flag to tell we're dealing with a line-scanning session. By default 'regular',
                      which means standard whole-brain acquisitions.

Example:
  spinoza_scanner2bids /path/to/project_root /path/to/your/project/sourcedata     # regular
  spinoza_scanner2bids -n 1/path/to/project_root /path/to/your/project/sourcedata # regular|ses-1
  spinoza_scanner2bids (shows this help text)                                     # help
  spinoza_scanner2bids --lines -n 2 DIR_DATA_HOME DIR_DATA_SOURCE                 # lines|ses-2

Notes:
  Assumes the following data structure:
  PROJECT
  └── sourcedata
      └── sub-001
          └── ses-1
              ├── task
              └── DICOMs/PARRECs
              
  Converts to:
  PROJECT
  └── sub-001
      └── ses-1
          ├── anat
          ├── func
          ├── fmap
          └── phase

---------------------------------------------------------------------------------------------------------

EOF
    exit 1
}

#---------------------------------------------------------------------------------------------------------
# Deal with arguments

# Check for subject & session flags
OW=0
SES_TYPE="regular"
while getopts :-:os:n: argument
do
  case ${argument} in
    -)
      case "${OPTARG}" in
        lines)
          SES_TYPE="lines"
          ;;
        *)
          if [ "$OPTERR" = 1 ] && [ "${optspec:0:1}" != ":" ]; then
            echo "Unknown option --${OPTARG}, did you mean \"--lines\"?"
            exit 1
          fi
          ;;  
      esac;;    
    s)  sub=${OPTARG}
          ;;
    n)  ses=${OPTARG}
          ;;     
    o)  OW=1
          ;;                            
  esac
done

if [[ $# -lt 2 ]] ; then
  Usage >&2
  exit 1
fi

PROJECT_ROOT=${@:$OPTIND:1}
SOURCEDATA=${@:$OPTIND+1:1}

if [[ -z ${sub} ]]; then
  # loop through subjects
  search="${SOURCEDATA}/${SUBJECT_PREFIX}*"
else
  # read specified subjects into array
  IFS=', ' read -r -a search <<< "${sub}"
  search=${search[@]}
  unset IFS
fi

# 'import' some bash functions
source call_bashhelper

#-----------------------------------------------------------------------------
# Start clock
#-----------------------------------------------------------------------------
echo
echo "==================================================================================================="
printf "Convert raw data to nifti using dcm2niix\n"
start=`date +%s`
start_date=`date`

printf "Started at ${start_date}\n"
echo "==================================================================================================="

#-----------------------------------------------------------------------------
# Run it
for subID in ${search}; do

  # collect subject name
  if [[ ! -z ${sub} ]]; then
    sub_name=${SUBJECT_PREFIX}${subID}
  else
    sub_name=$(basename ${subID})
  fi

  if [[ ! -z ${ses} ]]; then
    nr=`echo ${ses} | sed -e 's/^[[:space:]]*//'`
    base_path=${sub_name}/ses-${nr}
    base=${sub_name}_ses-${nr}
    msg="${sub_name} ses-${ses}: already processed"
  else
    base_path=${sub_name}
    base=${sub_name}
    msg="${sub_name}: already processed"
  fi  

  input_dir=${SOURCEDATA}/${base_path}
  output_dir=${input_dir}/nifti
  bids_dir=${PROJECT_ROOT}/${base_path}

  if [[ ${OW} -eq 1 ]]; then
    rm -r ${bids_dir}/* 2>/dev/null
  fi

  if [[ ${SES_TYPE} == "regular" ]]; then

    if [[ -d ${bids_dir}/anat && -d ${bids_dir}/func ]]; then
      nr_anat=`ls -l ${bids_dir}/anat | grep "total" | cut -d' ' -f2`
      nr_func=`ls -l ${bids_dir}/func | grep "total" | cut -d' ' -f2`
      if [ ${nr_anat} -ne 0 ] && [ ${nr_func} -ne 0 ]; then
        echo "${msg}; use \"master -m 02 -o\" to overwrite"
        echo " anat = ${nr_anat} | func = ${nr_func}"
        continue
      fi
    fi

    if [[ ! -d ${input_dir} ]]; then
      echo "${sub_name}: \"${input_dir}\" does not exist"
      continue
    else

      echo
      echo "**************************************** Processing ${sub_name} ***************************************"
      
      # We're dealing with session-1, the anatomical and pRF-mapping part, so we'll use FromScannerToBIDS.py/call_dcm2niix.py
      echo "Regular scan session (whole-brain data); using call_pydcm2niix"
      call_pydcm2niix ${input_dir} True False 2019

      echo "Reorienting images to LPI (conform fMRIPrep)"
      # for convenience, reorient all files to RAS+ (used by nibabel & fMRIprep)
      files=`find ${bids_dir} -type f -name "*.nii.gz"`
      for f in ${files[@]}; do
        val=`fslval ${f} qform_xorient`
        if [ ${val} != "Left-to-Right" ]; then
          call_reorient -i ${f} -c nb
        fi
      done

    fi

  elif [[ ${SES_TYPE} == "lines" ]]; then

    # check if input directory exists
    if [[ ! -d ${input_dir} ]]; then
      echo "${sub_name}: could not find input directory \"${input_dir}\""
      continue
    else


      if [[ ! -d ${bids_dir}/anat && ! -d ${bids_dir}/func ]]; then

        echo
        echo "**************************************** Processing ${sub_name} ***************************************"
        echo "Line-scanning session; using call_dcm2niix"

        if [[ ! -d ${bids_dir}/anat ]]; then
          mkdir -p ${bids_dir}/anat
        fi

        if [[ ! -d ${bids_dir}/func ]]; then
          mkdir -p ${bids_dir}/func
        fi

        #-------------------------------------------------------------------------------------------------------------------------------
        # PARREC TO NIFTI
        if [[ -d ${output_dir} ]]; then
          echo "Directory exists, skipping conversion."
        else
          echo "Converting files to nifti-format"
          call_dcm2niix -i ${input_dir} -o ${output_dir}
        fi

        echo "BIDSifying data .."

        #-------------------------------------------------------------------------------------------------------------------------------
        # NIFTI TO BIDS

        ## Low resolution anatomical scan
        anat_lowres=`find "${input_dir}/planning/nifti" -type f \( -name "*real*" -and -name "*t10*" -and -name "*.nii.gz" \) 2>/dev/null`
        anat_t1map=`find "${input_dir}/planning/nifti" -type f \( -name "*real*" -and -name "*t29*" -and -name "*.nii.gz" \) 2>/dev/null`
        if [[ ! -f ${bids_dir}/anat/${base}_acq-MP2RAGE_T1w.nii.gz ]]; then
          if [[ -f ${anat_lowres} && -f ${anat_t1map} ]]; then

            min=`fslstats ${anat_lowres} -R | awk '{print $1}'`
            if [[ ${min} != "0.000000" ]]; then
              echo " Rescaling lowres MP2RAGE-file"
              call_maskmp2rage ${anat_lowres} ${anat_t1map} ${anat_lowres}
            fi

            echo " Relocating lowres MP2RAGE-file as ${base}_acq-MP2RAGE_T1w.nii.gz"
            cp ${anat_lowres} ${bids_dir}/anat/${base}_acq-MP2RAGE_T1w.nii.gz
            cp $(dirname ${anat_lowres})/$(basename ${anat_lowres} .nii.gz).json ${bids_dir}/anat/${base}_acq-MP2RAGE_T1w.json
          fi

        else
          echo " low resolution MP2RAGE exists"
        fi

        ## Multi-slice files
        motion_img=`find "${output_dir}" -type f \( -name "*motion*" -and -name "*.nii.gz" \) 2>/dev/null`
        IFS=$'\n' motion_img=($(sort <<<"${motion_img[*]}"))
        unset IFS    

        echo " Relocating multi-slice file (${#motion_img[@]})"
        for i in ${motion_img[@]}; do
          
          run=`get_id ${i} motion`
          if [[ -z ${run} ]]; then
            run=i
          fi

          fname=${bids_dir}/anat/${base}_acq-MP2RAGE_rec-motion${run}.nii.gz
          if [[ ! -f ${fname} ]]; then
            if [[ -f ${motion_img} ]]; then
              echo "  renaming to $(basename ${fname})"
              cp ${motion_img} ${fname}
              cp $(dirname ${motion_img})/$(basename ${motion_img} .nii.gz).json $(dirname ${fname})/$(basename ${fname} .nii.gz).json
            else
              echo " WARNING: apparently found ${n_motion} motion file(s), but cannot find file with \"motion${run}\" and \"*.nii.gz\""
            fi
          else
            echo "  ${base}_acq-9slice_run-${run}_T1w.nii.gz exists"
          fi
        done


        ## Single-slice
        slice_img=`find "${output_dir}" -type f \( -name "*1slice*" -and -not -name "*space*" -and -name "*anat*" -and -name "*.nii.gz" \) 2>/dev/null`
        
        # sort array (https://stackoverflow.com/questions/7442417/how-to-sort-an-array-in-bash)
        IFS=$'\n' slice_img=($(sort <<<"${slice_img[*]}"))
        unset IFS   

        # add counter in case run-X does not occur in file     
        count=0
        if [[ ! -z ${slice_img} ]]; then
          
          echo " Found 1slice-files"

          for slice in ${slice_img[@]}; do
            ((count++))

            # fetch run
            run=`run_id ${slice}`
            if [[ ${run} -eq 0 ]]; then
              run=${count}
            fi     
          
            bids_slice=${bids_dir}/anat/${base}_acq-1slice_run-${run}_T1w.nii.gz
            if [[ ! -f ${bids_slice} ]]; then
              if [[ -f ${slice} ]]; then
                echo "  renaming to $(basename ${bids_slice})"
                cp ${slice} ${bids_slice}
                cp $(dirname ${slice})/$(basename ${slice} .nii.gz).json $(dirname ${bids_slice})/$(basename ${bids_slice} .nii.gz).json
              fi
            else
              echo "  $(basename ${bids_slice}) exists"
            fi

          done
        
        else
          echo "  WARNING: no \"1slice\"-files were found in ${output_dir}"
        fi

        ## bold files
        bold_files=`find "${input_dir}" -type f \( -name "*bold_*" -and -name "*.lab" \) 2>/dev/null`

        # sort array (https://stackoverflow.com/questions/7442417/how-to-sort-an-array-in-bash)
        IFS=$'\n' bold_files=($(sort <<<"${bold_files[*]}"))
        unset IFS    

        count=0
        if [[ ! -z ${bold_files} ]]; then

          echo " Found raw bold-files (*.lab)"
  
          # get foldover direction
          info_file=`find "${DIR_DATA_DERIV}/pycortex/${sub_name}" -type f \( -name "*desc-info*" -and -name "*.csv" \) 2>/dev/null`
          if [[ -f ${info_file} ]]; then
            fold=`grep -A0 "foldover" ${info_file} | cut -d',' -f3`
          else
            # default to FH foldover
            fold="FH"
          fi

          echo "  foldover is set to: ${fold}"

          for bold in ${bold_files[@]}; do
            ((count++))

            # use run-1 as template
            slice_img=`find "${bids_dir}/anat" -type f \( -name "*1slice*" -and -name "*run-1*" -and -name "*.nii.gz" \) 2>/dev/null`
            
            # fetch task
            task=`task_id ${bold}`
            if [[ ${task} == "prf" ]]; then
              task="pRF"
            elif [[ ${task} == "sr" ]]; then
              task="SR"
            fi

            # fetch run
            run=`run_id ${bold}`
            if [[ ${run} -eq 0 ]]; then
              run=${count}
            fi   

            line_img=${bids_dir}/func/${base}_task-${task}_run-${run}_bold.nii.gz

            if [[ -f ${slice_img} ]]; then
              if [[ ! -f ${line_img} ]]; then
                call_createline "${slice_img}" "${line_img}" "16" "${fold}"

                if [[ $? != 0 ]]; then
                  echo
                  echo "---------------------------------------------------------------------------------------------------"
                  echo "ERROR in `basename ${0}`: call_createline exited with non-zero status"
                  exit 1
                fi

                echo "  wrote `basename ${line_img}`"
              else
                echo "  `basename ${line_img}` exists"
              fi
            else
              echo "  WARNING: could not find slice-img for \"1slice\" and \"run-1\""
            fi

          done
        
        else
          echo "  WARNING: no \"bold*.lab\"-files were found in ${input_dir}"
        fi

        # check if we also did partial 3DEPI stuff
        bold_files=`find "${input_dir}" -type f \( -name "*acq-3DEPI*" -and -name "*bold.nii.gz" \) 2>/dev/null`

        # sort array (https://stackoverflow.com/questions/7442417/how-to-sort-an-array-in-bash)
        IFS=$'\n' bold_files=($(sort <<<"${bold_files[*]}"))
        unset IFS

        count=0
        if [[ ! -z ${bold_files[@]} ]]; then
          echo " Found 3DEPI file(s)"

          for bold in ${bold_files[@]}; do

            # fetch run
            run=`run_id ${bold}`
            if [[ ${run} -eq 0 ]]; then
              run=${count}
            fi 

            func=`find "${output_dir}" -type f \( -name "*acq-3DEPI*" -and -name "*run-${run}*" -and -name "*bold.nii.gz" \) 2>/dev/null`
            fmap=`find "${output_dir}" -type f \( -name "*acq-3DEPI*" -and -name "*run-${run}*" -and -name "*epi.nii.gz" \) 2>/dev/null`
            phase=`find "${output_dir}" -type f \( -name "*acq-3DEPI*" -and -name "*run-${run}*" -and -name "*bold_ph.nii.gz" \) 2>/dev/null`
            task=`task_id ${func}`

            # -acq needs to be after task to be compatible with fMRIprep
            tmp_dir=$(dirname ${output_dir})/func
            if [[ ! -d ${tmp_dir} ]]; then
              mkdir -p ${tmp_dir}
            fi

            # rename 'bold', 'epi', and 'phase'
            fname=${tmp_dir}/${base}_task-${task}_run-${run}_acq-3DEPI
            for ext in "_bold.nii.gz" "_epi.nii.gz" "_bold_ph.nii.gz"; do
              ff=${fname}${ext}

              if [[ ${ext} == "_bold.nii.gz" ]]; then
                orig=${func}
                image="func"
              elif [[ ${ext} == "_epi.nii.gz" ]]; then
                orig=${fmap}
                image="fmap"
              elif [[ ${ext} == "_bold_ph.nii.gz" ]]; then
                orig=${phase}
                image="phase"
              fi

              if [[ ! -f ${ff} ]]; then
                if [[ -f ${orig} ]]; then
                  echo "  renaming ${image}-file to `basename ${ff}`"
                  cp ${orig} ${ff}
                  cp $(dirname ${orig})/$(basename ${orig} .nii.gz).json $(dirname ${ff})/$(basename ${ff} .nii.gz).json
                fi
              else
                echo "  $(basename ${ff}) exists"
              fi

            done

          done

          # check for physio files
          phys=`find "${input_dir}" -type f \( -name "SCANPHYS*" -and -name "*bold_*.log" \) 2>/dev/null`

          # sort array
          IFS=$'\n' phys=($(sort <<<"${phys[*]}"))
          unset IFS
          if [[ ! -z ${phys} ]]; then

            echo " Found physio file(s)"
            if [[ ! -d ${bids_dir}/physio ]]; then
              mkdir -p ${bids_dir}/physio
            fi            

            count=0
            for file in ${phys[@]}; do
              
              # add counter in case file does not contain run-X id
              ((count++))

              # fetch task
              task=`task_id ${file}`
              if [[ ${task} == "prf" ]]; then
                task="pRF"
              else
                task=${task^^}
              fi

              # fetch run
              run=`run_id ${file}`
              if [[ ${run} -eq 0 ]]; then
                run=${count}
              fi              

              bids_phys=${bids_dir}/physio/${base}_task-${task}_run-${run}_physio.log
              if [[ ! -f ${bids_phys} ]]; then
                echo "  renaming physio-file to `basename ${bids_phys}`"
                cp ${file} ${bids_phys}
              fi              
            done
          fi
          echo " Done"
        fi
        echo "Done"
      else
        echo "${msg}; use \"master -m 02 -o\" to overwrite"
      fi
    fi
  else
    echo "Invalid session-type \"${SES_TYPE}\". Must be 'regular' or 'lines'"
    continue
  fi

done

#---------------------------------------------------------------------------------------------------------
# make dataset_description file if it doesn't exist. User enters a line for the description

if [[ ! -f ${DIR_DATA_HOME}/dataset_description.json ]]; then

  cd ${DIR_DATA_HOME}
  echo "enter the name of the project and press [ENTER]: " && read DESCRIPTION

  (
  echo "{"
  echo "    \"Name\": \"${DESCRIPTION}\","
  echo "    \"BIDSVersion\": \"1.2.2\","
  echo "    \"License\": \"RECOMMENDED. What license is this dataset distributed under?. The use of license name abbreviations is suggested for specifying a license\","
  echo "    \"Authors\": ["
  echo "        \"G.J. Heij\""
  echo "    ],"
  echo "    \"Acknowledgements\": \"OPTIONAL. List of individuals who contributed to the creation/curation of the dataset\","
  echo "    \"HowToAcknowledge\": \"OPTIONAL. Instructions how researchers using this dataset should acknowledge the original authors. This field can also be used to define a publication that should be cited in publications that use the dataset\","
  echo "    \"Funding\": ["
  echo "        \"OPTIONAL. List of sources of funding (grant numbers)\""
  echo "    ],"
  echo "    \"ReferencesAndLinks\": ["
  echo "        \"OPTIONAL. List of references to publication that contain information on the dataset, or links\","
  echo "        \"https://github.com/Donders-Institute/bidscoin\""
  echo "    ],"
  echo "    \"DatasetDOI\": \"OPTIONAL. The Document Object Identifier of the dataset (not the corresponding paper)\""
  echo "}"
  ) > dataset_description.json

  cd -

fi

#-----------------------------------------------------------------------------
# Calculate time spent using 'let'
echo
echo "---------------------------------------------------------------------------------------------------"
end=`date +%s`
end_date=`date`
printf "Done at ${end_date}\n"

let deltatime=end-start
let hours=deltatime/3600
let minutes=(deltatime/60)%60
let seconds=deltatime%60
printf "Time spent: %d:%02d:%02d\n" ${hours} ${minutes} ${seconds}
echo "---------------------------------------------------------------------------------------------------"
echo
