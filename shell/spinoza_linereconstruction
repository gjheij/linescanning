#!/usr/bin/env bash

#---------------------------------------------------------------------------------------------------------
# check if there's is a setup file containing the major paths and source it if it exists
call_loadsetup

#---------------------------------------------------------------------------------------------------------
# Create help text
function Usage {
    cat <<USAGE

---------------------------------------------------------------------------------------------------
spinoza_linereconstruction

wrapper for call_linerecon that performs the reconstruction of the line data. Uses MRecon, so we can
only run it on the spinoza cluster. It calls upon call_linerecon, which internally uses a template
for the reconstruction with MRecon based on scripts provided by Luisa Raimondo.

Usage:
  spinoza_linereconstruction <project root directory> <sourcedata>

Arguments:
  -s <subject>        subject ID (e.g., 01, 001, or 1)
  -n <session>        session ID (e.g., 1, 2, or n)
  -m <n_echoes>       number of echoes in the acquisition (e.g., 5)
  -j                  submit job to cluster (SGE)
  -o                  overwrite existing files
  <project root>      base directory containing the derivatives and the subject's folders.
  <sourcedata>        base directory containing the raw data for reconstruction

Eample:
  spinoza_linereconstruction ${DIR_DATA_HOME} ${DIR_DATA_SOURCE}

Notes:
  relies on matlab scripts stored in '/data1/projects/MicroFunc/common'. As it relies on MRecon,
  we can only run this on the spinoza server

  run with master:  "master -m 03 -s 003 -n 4 -x 5" (sub-003, ses-4, multi-echo (5) acquisition)
                    "master -m 03 -s 003 -n 4"      (sub-003, ses-4, single-echo acquisition)
                    "master -m 03 -s 003 -n 4 -x 5 -j" (submit to cluster)
                    "master -m 03 -s 003 -n 4 -x 5 -o" (overwrite existing files)
                    "master -m 03 -s 003 -n 4 -x 5 -o -j" (overwrite and submit)

  Runs by default NORDIC denoising!
---------------------------------------------------------------------------------------------------

USAGE
    exit 1
}

if [[ $# -lt 2 ]] ; then
  Usage >&2
  exit 1
fi

# Check for subject & session flags
while getopts ojs:n:m: argument
do
    case ${argument} in
      s)  sub=${OPTARG}
            ;;
      n)  ses=${OPTARG}
            ;;
      m)  n_echoes=${OPTARG}
            ;;                
    esac
done

OUTPUT=${@:$OPTIND:1}
INPUT=${@:$OPTIND+1:1}

#-----------------------------------------------------------------------------
# Get bash helper functions
source call_bashhelper

if [[ -z ${sub} ]]; then
  # loop through subjects
  search="${INPUT}/${PREFIX}*"
else
  # do for 1 subject
  sub_nr=`echo ${sub} | sed -e 's/^[[:space:]]*//'`
  search="${INPUT}/${PREFIX}${sub_nr}"
fi

if [[ ! -z ${ses} ]]; then
  nr=`echo ${ses} | sed -e 's/^[[:space:]]*//'`
fi

if [[ "${@}" == *"-o"* ]]; then
  OW=1
else
  OW=0
fi

if [[ "${@}" == *"-j"* ]]; then
  SGE=1
else
  SGE=0
fi

if [[ ! -z ${n_echoes} ]]; then
  echo_flag="-m ${n_echoes}"
else
  echo_flag=""
fi

#-----------------------------------------------------------------------------
# Start clock
#-----------------------------------------------------------------------------

echo
echo "==================================================================================================="
printf "DATA RECONSTRUCTION WITH MRECON [LUISA]\n"
start=`date +%s`
start_date=`date`

printf "Started at ${start_date}\n"
echo "==================================================================================================="

#-----------------------------------------------------------------------------
# Run it

for dir in ${search}; do

  lab_func=${INPUT}/$(basename ${dir})/ses-${nr}
  if [[ -d ${lab_func} ]]; then

    bidsfunc=${OUTPUT}/$(basename ${dir})/ses-${nr}/func
    if [[ ! -d ${bidsfunc} ]]; then
      mkdir -p ${bidsfunc}
    fi

    # fetch and sort the lab-files
    bold_files=`find "${lab_func}" -type f \( -name "*bold_*" -and -name "*.lab" \) 2>/dev/null`
    IFS=$'\n' bold_files=($(sort <<<"${bold_files[*]}"))
    unset IFS 

    if [[ -z ${bold_files} ]]; then
      echo "`basename ${dir}`: Could not find BOLD-data"
      continue
    fi
    
    # fetch and sort the lab-files
    lsd_files=`find "${lab_func}" -type f \( -name "*desc-recon*" -and -name "*.lab" \) 2>/dev/null`
    IFS=$'\n' lsd_files=($(sort <<<"${lsd_files[*]}"))
    unset IFS

    if [[ -z ${lsd_files} ]]; then
      echo "`basename ${dir}`: Could not find LSD-image(s)"
      continue
    fi    

    if [[ ${PLACE} == "SGE" ]]; then

      echo
      echo "**************************************** Processing `basename ${dir}` ***************************************"

      count=0
      for bold in ${bold_files[@]}; do

        ((count++))

        # fetch run
        run=`run_id ${bold}`
        if [[ ${run} -eq 0 ]]; then
          run=${count}
        fi

        # fetch task
        task=`task_id ${bold}`

        # set output name
        outputbase=${bidsfunc}/$(basename ${dir})_ses-${nr}_task-${task}_run-${run}_bold
        if [[ ${OW} -eq 1 ]]; then
          rm -r ${outputbase}.mat 2>/dev/null
        fi

        if [[ ! -f ${outputbase}.mat ]]; then
          
          IDnr=`basename ${dir} | cut -d'-' -f2`
          # find corresponding LSD-image
          if [[ ${#lsd_files} -gt 1 ]]; then
            lsd=${lsd_files[$((${count}-1))]}
          else
            lsd=${lsd_files[0]}
          fi

          if [[ ${SGE} -eq 1 ]]; then
            job="qsub -N recon_${IDnr}_${run} -wd ${OUTPUT}/$(basename ${dir})/ses-${nr}"
          else
            echo "Running recon for run-${run}"
            job="bash"
          fi

          ${job} ${DIR_SCRIPTS}/bin/call_linerecon -r ${run} ${echo_flag} ${bold} ${lsd} ${outputbase}

        else

          echo "${outputbase}.mat exists"

        fi

      done

    else

      echo "Sneaky, but I told you in the usage that we can run this on the server only;)"
      echo "For good measures:"
      Usage >&2
      exit 1

    fi

  else

    echo "`basename ${dir}`: ses-${nr} not yet performed"
    continue

  fi

done

#-----------------------------------------------------------------------------
# Calculate time spent using 'let'
echo
echo "---------------------------------------------------------------------------------------------------"
end=`date +%s`
end_date=`date`
printf "Done at ${end_date}\n"

let deltatime=end-start
let hours=deltatime/3600
let minutes=(deltatime/60)%60
let seconds=deltatime%60
printf "Time spent: %d:%02d:%02d\n" ${hours} ${minutes} ${seconds}
echo "---------------------------------------------------------------------------------------------------"
