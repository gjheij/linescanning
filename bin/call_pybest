#!/usr/bin/env bash
#$ -S /bin/bash
#$ -j Y
#$ -cwd
#$ -V

source ${SETUP_FILE}

#---------------------------------------------------------------------------------------------------------
# Create help text
function Usage {
    cat <<USAGE

---------------------------------------------------------------------------------------------------
call_pybest

wrapper for pybest that takes the output from fMRIprep and denoises the data. The output of this
script is a set up numpy arrays that can be loaded in by prf_fitting.ipynb. It is important to
have pybest in a conda environment, as it uses the newest version of Nilearn which has not been
released yet (https://github.com/nilearn/nilearn). By default, call_pybest will look for an envi-
ronment called fmriprep_denoising, but you can specify your own environment as long as it has py-
best in it. Check for instruction this page https://github.com/lukassnoek/pybest. As far as I've 
tested, it only works with surface files. Volumetric data outputs pepper corn noise pattern.

Usage:
  call_pybest -r <subject number> -n <session number> -o <output directory> -s <space>
              -f <fprep dir> -c <slots>

Arguments:
  -s <sub number>     number of subject's FreeSurfer directory from which you can omit "sub-" (e.g.,
                      for "sub-001", enter "001"). If left empty pybest will process everything it
                      can find in the fmriprep folder
  -n <ses number>     session number. If left empty or 'all', pybest will process everything it 
                      can find in the fmriprep folder.
  -o <output dir>     path to output directory. By default it will create a subject-specific folder,
                      but you can set where that subject folder is going to go. By default this
                      script will output to /projectroot/derivatives/pybest
  -r <space>          the space to process. fMRIprep outputs several kinds of standard spaces such
                      as the MNI152NLin2009cAsym, or FSL-templates, but also fsnative. The latter
                      is the default, because we want to project the results in pycortex.
  -f <fprep dir>      path to fmriprep derivatives directory. Will look by default in the /project/
                      derivatives/fmriprep
  -c <n_slots>        number of slots to use when we're on a cluster
  -p <n_comps>        number of components to use for decomposition. Default = 10
  --raw               undo the z-scoring done by pybest (call_unzscore)

Example:
  call_pybest -s "001" -n "1" -o /derivatives/pybest -r "fsnative" -f /derivatives/fmriprep -c 10
  call_pybest -s "001" -n "1" -o /derivatives/pybest -p 25 -f /derivatives/fmriprep -c 10

---------------------------------------------------------------------------------------------------

USAGE
    exit 1
}

# set defaults that will be overwritten if flags are given
task_ids=${TASK_SES1[@]}
sub_input=""
cpu_input=""
check_env="base"
ses_input=""
output_dir=${DIR_DATA_DERIV}/pybest
input_dir=${DIR_DATA_DERIV}/fmriprep
raw=1
n_comps=10
while getopts :-:s:n:o:f:c:v:r:t:p: arg; do
  case $arg in
    -)
      case "${OPTARG}" in
        no_raw)
          raw=0
          ;;  
        fsaverage)
          in_space="fsaverage"
          ;; 
        fsnative)
          in_space="fsnative"
          ;;                                                          
        *)
          if [ "$OPTERR" = 1 ] && [ "${optspec:0:1}" != ":" ]; then
            echo "Unknown option --${OPTARG}"
            exit 1
          fi
          ;;
      esac;;   
    s)  sub=${OPTARG}
          ;;
    n)  ses=${OPTARG}
          ;;
    o)  outputdir=${OPTARG}
          ;;
    r)  in_space=${OPTARG}
          ;;
    f)  fprepdir=${OPTARG}
          ;;
    c)  n_slots=${OPTARG}
          ;;
    t)  task_ids=(${OPTARG})
          ;;  
    p)  n_comps=${OPTARG}
          ;;                    
  esac
done

if [[ $# -lt 4 ]] ; then
  Usage >&2
  exit 1
fi

# Make sure we run the specified subject or all subjects pybest can find will be
# processed
if [[ ! -z ${sub} ]]; then
  sub_input="--subject ${sub}"
fi

# Make sure we run the specified session or all sessions pybest can find will be
# processed
base_dir="sub-${sub}/"
if [[ ! -z ${ses} ]]; then
  if [[ ${ses} != "all" ]]; then
    ses_input="--session ${ses}"
    base_dir+="/ses-${ses}"
  fi
fi

# Set output directory if specified, otherwise default to /derivatives/pybest
if [[ ! -z ${outputdir} ]]; then
  output_dir=${outputdir}
fi

# Set input directory if specified, otherwise default to /derivatives/pybest
if [[ ! -z ${fprepdir} ]]; then
  input_dir=${fprepdir}
fi

# Make sure we run with the specified amount of slots
if [[ ! -z ${n_slots} ]]; then
  cpu_input="--n-cpus ${n_slots}"
fi

#
if [[ ! -d ${output_dir}/sub-${sub} ]]; then
  mkdir -p ${output_dir}/sub-${sub}
fi 

# loop through tasks; I know pybest can do ALL tasks at once, but it's nice to have a limiter in here
for task_id in ${task_ids[@]}; do
  echo "Running pybest on task: \"${task_id}\""
  if [[ ${in_space} == "fsnative" || ${in_space} == "fsaverage" ]]; then
    
    # save standard deviation and mean in tmp/ folder (pkl files)
    if [ ${raw} -eq 1 ]; then
      echo "Saving average/standard deviation"
      call_unzscore \
        -s ${sub} \
        -n ${ses} \
        -o ${DIR_DATA_DERIV}/pybest \
        -f ${input_dir} \
        -t ${task_id} \
        -p ${in_space} \
        --pre
    fi

    for hemi in "L" "R"; do

      echo "Dealing with hemi-${hemi}"

      cmd="""pybest \
        ${sub_input} \
        ${ses_input} \
        --task ${task_id} \
        --space ${in_space} \
        --hemi ${hemi} \
        ${cpu_input} \
        --verbose ERROR \
        --save-all ${input_dir} \
        --n-comps ${n_comps}"""

      echo ${cmd}
      eval ${cmd}

      if [[ $? -ne 0 ]]; then
        echo "ERROR in `basename ${0}`: pybest existed with non-zero status"
        exit 1
      fi

    done

    # undo z-scoring
    if [ ${raw} -eq 1 ]; then
      echo "Un-zcoring output from pybest"

      call_unzscore \
        -s ${sub} \
        -n ${ses} \
        -o ${DIR_DATA_DERIV}/pybest \
        -f ${input_dir} \
        -t ${task_id} \
        -p ${in_space} \
        --post
    fi

    echo "Done"
    
  else

    pybest \
      ${sub_input} \
      ${ses_input} \
      --task ${task_id} \
      --space ${in_space} \
      --verbose ERROR \
      --save-all ${input_dir} \
      --n-comps ${n_comps}

    if [[ $? -ne 0 ]]; then
      echo "ERROR in `basename ${0}`: pybest existed with non-zero status"
      exit 1
    fi    
  fi
done
