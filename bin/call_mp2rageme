#!/usr/bin/env python

# # ME-MP2RAGE
#
# `MEMP2RAGE` is a subclass of `MP2RAGE` to can deal with multi-echo MP2RAGE data.
# In such a dataset, you collect multiple echoes for the second inversion time. These echoes are all T2\*-weighted
# and by fitting an exponentially decaying curve to their signal intensities, you can estimate the quantitative
# T2\* map of the image.
#
# Note that segmentation of gray vs white matter, as well as subcortical nuclei can be considerably improved by not using only T1, but also T2(\*) information.
#
# We start by importing the MEMP2RAGE-class (rather than the MP2RAGE-class).

from pymp2rage import MEMP2RAGE
import os
import pathlib
import sys, getopt
import json
import warnings
from bids import BIDSLayout
import nibabel as nb
import numpy as np
import platform
from linescanning.utils import get_file_from_substring
warnings.filterwarnings("ignore")
opj = os.path.join

def main(argv):

    """
---------------------------------------------------------------------------------------------------
call_memp2rage

This script is a wrapper for the memp2rage object that can calculate a Unified T1-weighted
image and a quantitative T1 map, based on the magnitude and phase-information of the two
volumes of a MP2RAGE-sequence (Marques et al., 2010). It can also further correct this map
for B1 inhomogenieties using a B1 map (Marques et al., 2014) and calculated several para-
metric maps (R2*, t1map, t2*)

Args:
    -s (--subject=)     subject number      (i was a bit lazy in programming this, given that regexp
                                            are kind of annoying in python, I think. So just input
                                            the subject number as specified in the paths)
    -n (--session=)     session number      session number, needed for extraction of the right files
    -i (--inputdir=)    input directory     project root directory with the subject-directories on
                                            which we need to run the script. <subject> will be ap-
                                            pended, as well as the session nr if specified
    -o (--outputdir=)   output directory    path to pymp2rage. <subject> and <ses-x> (optional), will be appended
    -c                  make INV2 mask      no input required

Outputs:
    r2star (Nifti1Image):       Relaxation map (1/T2*)
    t2star (Nifti1Image):       T2*-weighted image
    t2starmap (Nifti1Image):    Quantitative T2* map
    t1map (Nifti1Image):        Quantitative T1 map
    t1w_uni (Nifti1Image):      Bias-field corrected T1-weighted image
    s0 (Nifti1Image):           Residual (S0) map


Example:
    call_memp2rage -s sub-999 -n 1 -i $DIR_DATA_HOME -o $DIR_DATA_DERIV/pymp2rage

Notes:
    - Assumes you ran spinoza_scanner2bids before. If not, change the required filenames in the
      script
    - This deals with pseudo-BIDSified data structure. It does, however, assume you have only 1 run.
    - The input directory should be the directory where your "to-be-processed" data is, where all
      your sub's are located could be in the main branch of "Project X" or under "sourcedata"

    > project Y
    > Project X
        > sourcedata
        > derivatives
          >pymp2rage  << This is the output folder!
        > 001
            > anat
            > func

---------------------------------------------------------------------------------------------------

    """

    inputdir    = ''
    subject     = ''
    session     = None
    outputdir   = None
    outputbase  = "sample_desc"
    do_stuff    = False

    try:
        opts = getopt.getopt(argv,"hci:s:n:o:",["inputdir=", "subject=", "outputdir=", "outputbase="])[0]
    except getopt.GetoptError:
        print(main.__doc__)
        sys.exit(2)

    for opt, arg in opts:
        if opt == '-h':
            print(main.__doc__)
            sys.exit()
        elif opt in ("-i", "--inputdir"):
            inputdir = arg
        elif opt in ("-o", "--outputdir"):
            outputdir = arg
        elif opt in ("-s", "--subject"):
            subject = args
        elif opt in ("-b", "--outputbase"):
            outputbase = arg
        elif opt in ("-c"):
            do_stuff = True            

    if len(argv) < 6:
        print("NOT ENOUGH ARGUMENTS SPECIFIED")
        print(main.__doc__)
        sys.exit(1)

    # Define paths to images
    bids_fn     = BIDSLayout(opj(inputdir), validate=False).get(extension=['nii.gz'], return_type='file')
    select_fn   = get_file_from_substring(['inv', 'acq-MP2RAGEME'], bids_fn)
    select_fn.sort()

    if len(select_fn) != 10:
        print("For MEMP2RAGE-reconstruction we should have 10 files; got {}".format(len(select_fn)))
        sys.exit(1)

    print("Loading all images to the memp2rage object")
    memp2rage = MEMP2RAGE(echo_times=[0.006, 0.0145, 0.023, 0.0315], # TEs of second inversion in seconds
                          MPRAGE_tr=6.723,
                          invtimesAB=[0.67, 3.68],
                          flipangleABdegree=[4,4],
                          nZslices=150,
                          FLASH_tr=[0.0062, 0.031246], # TRs of the first and second GRE block are
                          inv1      = select_fn[0],
                          inv1ph    = select_fn[1],
                          inv2      = [select_fn[2],select_fn[4],select_fn[6],select_fn[8]],
                          inv2ph    = [select_fn[3],select_fn[5],select_fn[7],select_fn[9]]
                          )

    # create output directory
    pathlib.Path(outputdir).mkdir(parents=True, exist_ok=True)

    # Calculate and right multiparametric maps to outputdir
    OUTPUT  = {
        'r2starmap':   opj(outputdir, f'{outputbase}_R2starmap.nii.gz'),
        't1w_uni':     opj(outputdir, f'{outputbase}_T1w.nii.gz'),
        't1map':       opj(outputdir, f'{outputbase}_T1map.nii.gz'),
        't2starw':     opj(outputdir, f'{outputbase}_T2starw.nii.gz'),
        't2starmap':   opj(outputdir, f'{outputbase}_T2starmap.nii.gz'),
        's0':          opj(outputdir, f'{outputbase}_S0.nii.gz')
        }

    def write_nifti(FILE, DESC):
        if os.path.isfile(FILE):
            print(" {} already exists".format(os.path.basename(FILE)))
        else:
            print(" writing " + os.path.basename(FILE))

            if DESC == 'r2starmap':
                memp2rage.r2starmap.to_filename(FILE)
                params =    {
                            'BasedOn':
                                [
                                os.sep.join(select_fn[2].split(os.sep)[-(len(select_fn[2].split(os.sep))-select_fn[2].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[4].split(os.sep)[-(len(select_fn[4].split(os.sep))-select_fn[4].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[6].split(os.sep)[-(len(select_fn[6].split(os.sep))-select_fn[6].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[8].split(os.sep)[-(len(select_fn[8].split(os.sep))-select_fn[8].split(os.sep).index(subject)-1):]),
                                ],
                            'EstimationReference': 'Caan et al., 2019',
                            "EstimationAlgorithm": "Ordinary Least Squares in Log-space",
                            "EstimationSoftwareName": "pymp2rage",
                            "EstimationSoftwareVer": "v0.1",
                            "EstimationSoftwareLang": "python {}".format(platform.python_version()),
                            "EstimationSoftwareEnv": "{}".format(platform.platform())
                            }

                JSON_FILE = FILE.split('.')[0]+'.json'

                if os.path.isfile(JSON_FILE):
                    print(f" {os.path.basename(JSON_FILE)} already exists")
                else:
                    print(" writing " + os.path.basename(JSON_FILE))

                with open(JSON_FILE, "w+") as file:
                    json.dump(params, file, indent=4)

            elif DESC == 't1w_uni':
                memp2rage.t1w_uni.to_filename(FILE)
                params =    {
                            'BasedOn':
                                [
                                os.sep.join(select_fn[0].split(os.sep)[-(len(select_fn[0].split(os.sep))-select_fn[0].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[1].split(os.sep)[-(len(select_fn[1].split(os.sep))-select_fn[1].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[2].split(os.sep)[-(len(select_fn[2].split(os.sep))-select_fn[2].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[3].split(os.sep)[-(len(select_fn[3].split(os.sep))-select_fn[3].split(os.sep).index(subject)-1):]),
                                ],
                            'EstimationReference': 'Caan et al., 2019',
                            "EstimationAlgorithm": "memp2rage unified T1-weighted image",
                            "EstimationSoftwareName": "pymp2rage",
                            "EstimationSoftwareVer": "v0.1",
                            "EstimationSoftwareLang": "python {}".format(platform.python_version()),
                            "EstimationSoftwareEnv": "{}".format(platform.platform())
                            }

                JSON_FILE = FILE.split('.')[0]+'.json'

                if os.path.isfile(JSON_FILE):
                    print(f" {os.path.basename(JSON_FILE)} already exists")
                else:
                    print(" writing " + os.path.basename(JSON_FILE))

                with open(JSON_FILE, "w+") as file:
                    json.dump(params, file, indent=4)

            elif DESC == 't1map':
                memp2rage.t1map.to_filename(FILE)
                params =    {
                            'BasedOn':
                                [
                                os.sep.join(select_fn[0].split(os.sep)[-(len(select_fn[0].split(os.sep))-select_fn[0].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[1].split(os.sep)[-(len(select_fn[1].split(os.sep))-select_fn[1].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[2].split(os.sep)[-(len(select_fn[2].split(os.sep))-select_fn[2].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[3].split(os.sep)[-(len(select_fn[3].split(os.sep))-select_fn[3].split(os.sep).index(subject)-1):]),
                                ],
                            'EstimationReference': 'Caan et al., 2019',
                            "EstimationAlgorithm": "memp2rage T1 map",
                            "EstimationSoftwareName": "pymp2rage",
                            "EstimationSoftwareVer": "v0.1",
                            "EstimationSoftwareLang": "python {}".format(platform.python_version()),
                            "EstimationSoftwareEnv": "{}".format(platform.platform())
                            }

                JSON_FILE = FILE.split('.')[0]+'.json'

                if os.path.isfile(JSON_FILE):
                    print(" " + os.path.basename(JSON_FILE) + " already exists" )
                else:
                    print(" writing " + os.path.basename(JSON_FILE))

                with open(JSON_FILE, "w+") as file:
                    json.dump(params, file, indent=4)

            elif DESC == 't2starw':
                pass
                memp2rage.t2starw.to_filename(FILE)
                params =    {
                            'BasedOn':
                                [
                                os.sep.join(select_fn[2].split(os.sep)[-(len(select_fn[2].split(os.sep))-select_fn[2].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[4].split(os.sep)[-(len(select_fn[4].split(os.sep))-select_fn[4].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[6].split(os.sep)[-(len(select_fn[6].split(os.sep))-select_fn[6].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[8].split(os.sep)[-(len(select_fn[8].split(os.sep))-select_fn[8].split(os.sep).index(subject)-1):]),
                                ],
                            'EstimationReference': 'Caan et al., 2019',
                            "EstimationAlgorithm": "Ordinary Least Squares in Log-space",
                            "EstimationSoftwareName": "pymp2rage",
                            "EstimationSoftwareVer": "v0.1",
                            "EstimationSoftwareLang": "python {}".format(platform.python_version()),
                            "EstimationSoftwareEnv": "{}".format(platform.platform())
                            }

                JSON_FILE = FILE.split('.')[0]+'.json'

                if os.path.isfile(JSON_FILE):
                    print(f" {os.path.basename(JSON_FILE)} already exists")
                else:
                    print(" writing " + os.path.basename(JSON_FILE))

                with open(JSON_FILE, "w+") as file:
                    json.dump(params, file, indent=4)

            elif DESC == 't2starmap':
                memp2rage.t2starmap.to_filename(FILE)
                params =    {
                            'BasedOn':
                                [
                                os.sep.join(select_fn[0].split(os.sep)[-(len(select_fn[0].split(os.sep))-select_fn[0].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[1].split(os.sep)[-(len(select_fn[1].split(os.sep))-select_fn[1].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[2].split(os.sep)[-(len(select_fn[2].split(os.sep))-select_fn[2].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[3].split(os.sep)[-(len(select_fn[3].split(os.sep))-select_fn[3].split(os.sep).index(subject)-1):]),
                                ],
                            'EstimationReference': 'Caan et al., 2019',
                            "EstimationAlgorithm": "MP2RAGE unified T1-weighted image",
                            "EstimationSoftwareName": "pymp2rage",
                            "EstimationSoftwareVer": "v0.1",
                            "EstimationSoftwareLang": "python {}".format(platform.python_version()),
                            "EstimationSoftwareEnv": "{}".format(platform.platform())
                            }

                JSON_FILE = FILE.split('.')[0]+'.json'

                if os.path.isfile(JSON_FILE):
                    print(f" {os.path.basename(JSON_FILE)} already exists")
                else:
                    print(" writing " + os.path.basename(JSON_FILE))

                with open(JSON_FILE, "w+") as file:
                    json.dump(params, file, indent=4)

            elif DESC == 's0':
                pass
                memp2rage.s0.to_filename(FILE)
                params =    {
                            'BasedOn':
                                [
                                os.sep.join(select_fn[2].split(os.sep)[-(len(select_fn[2].split(os.sep))-select_fn[2].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[4].split(os.sep)[-(len(select_fn[4].split(os.sep))-select_fn[4].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[6].split(os.sep)[-(len(select_fn[6].split(os.sep))-select_fn[6].split(os.sep).index(subject)-1):]),
                                os.sep.join(select_fn[8].split(os.sep)[-(len(select_fn[8].split(os.sep))-select_fn[8].split(os.sep).index(subject)-1):]),
                                ],
                            'EstimationReference': 'Caan et al., 2019',
                            "EstimationAlgorithm": "Ordinary Least Squares in Log-space",
                            "EstimationSoftwareName": "pymp2rage",
                            "EstimationSoftwareVer": "v0.1",
                            "EstimationSoftwareLang": "python {}".format(platform.python_version()),
                            "EstimationSoftwareEnv": "{}".format(platform.platform())
                            }

                JSON_FILE = FILE.split('.')[0]+'.json'

                if os.path.isfile(JSON_FILE):
                    print(f" {os.path.basename(JSON_FILE)} already exists")
                else:
                    print(" writing " + os.path.basename(JSON_FILE))

                with open(JSON_FILE, "w+") as file:
                    json.dump(params, file, indent=4)

    print("Creating output files")
    for p in OUTPUT:
        write_nifti(OUTPUT[p], p)

        tmp = getattr(memp2rage, p).get_fdata()
        tmp = np.nan_to_num(tmp)
        nb.Nifti1Image(tmp.astype('float32'), affine=getattr(memp2rage, p).affine, header=getattr(memp2rage, p).header).to_filename(OUTPUT[p])

    if do_stuff:
        brainmask = opj(outputdir, f'{outputbase}_desc-spm_mask.nii.gz')
        if not os.path.exists(brainmask):

            try:
                print("Make mask with FSL from INV2-image")
                cmd = f"bet2 {select_fn[2]} {opj(inputdir, 'tmp')} -m -f 0.2"
                os.system(cmd)
            except:
                pass
            
            try:
                print("Make mask with SPM from INV2-image")
                cmd = f'call_spmmask {select_fn[2]} {brainmask} y'
                os.system(cmd)
            except:
                pass
            
            # SPM-mask sometimes gets rid of a part of the cerebellum; adding FSL's bet2 mask to it improves this area, 
            # but also leaves in more dura. This will be removed, however, during the CAT12 stage
            if os.path.exists(brainmask) and os.path.exists(opj(inputdir, 'tmp_mask.nii.gz')):
                
                print("Combining SPM & FSL mask to include cerebellum too")

                new_mask = image.math_img('(spm + fsl) > 0', spm=brainmask, fsl=opj(inputdir, 'tmp_mask.nii.gz'))
                new_mask.to_filename(brainmask)

                # remove files starting with 'tmp'
                remove_files(inputdir, 'tmp', ext=False)

        # try:
        print("Removing background")
        os.system(f"call_rmbackground -t {OUTPUT['t1w_uni']} -m {brainmask} -i {select_fn[2]} -o {OUTPUT['t1w_uni']}")
        # except:
        #     pass
        print("TIP: check the brain mask; if needed, edit it, remove T1w.nii.gz-file and re-run")

    print("Done")

if __name__ == "__main__":
    main(sys.argv[1:])
