#!/usr/bin/env bash

function conda2jupyter {
  conda activate ${1}
  python -m ipykernel install --user --name=${1}
  conda deactivate
}

function reverse_array {
  array=("${@}")
  min=0
  max=$(( ${#array[@]} -1 ))

  while [[ min -lt max ]]
  do
      # Swap current first and last elements
      x="${array[$min]}"
      array[$min]="${array[$max]}"
      array[$max]="$x"

      # Move closer
      (( min++, max-- ))
  done

  IFS=" "
  read -ra arr <<< "$array"
}

function recache_mpl_fonts {
  
  cache_file=`find ~/.cache/matplotlib -type f -name "*fontlist*"`
  if [[ ! -z ${cache_file} ]]; then
    rm -r ${cache_file} 2>/dev/null
  fi

  python_code="""import matplotlib.font_manager; matplotlib.font_manager._load_fontmanager(try_read_cache=False);"""
  python3 -c "${python_code}"
}

function find_hierarchical_anatomy {

  #---------------------------------------------------------------------------------------------------------
  # Create help text
  function Usage {
      cat <<USAGE

---------------------------------------------------------------------------------------------------
find_hierarchical_anatomy

Find the correct folder with anatomies depending on the processing steps that you've conduc-
ted. The following codes represent certain stages of anatomical preprocessing:
  1 = DIR_DATA_HOME; no preprocessing has done, take the T1w from the scanner
  2 = DIR_DATA_DERIV/pymp2rage; combination with pym2rage; if not present, default to DIR_DATA_HOME
  3 = DIR_DATA_DERIV/denoising; denoising with CAT12 (sanlm); if not present, look for pymp2rage, 
      then DIR_DATA_HOME
  4 = DIR_DATA_DERIV/cat12; segmentation with CAT12 (sanlm); if not present, look for denoised, py-
      mp2rage, then DIR_DATA_HOME      
  5 = DIR_DATA_DERIV/masked_${DATA,,}; anatomicals void of garbage such as sinus. If not present, 
      look for "denoised" > "pymp2rage" > "DIR_DATA_HOME"
  6 = Same as 5, but instead of looking for intermediate folders (denoised/pymp2rage), directly go 
      to DIR_DATA_HOME

Args:
 <code> 1-6

Usage:
 find_hierarchical_anatomy 1
 find_hierarchical_anatomy 5

---------------------------------------------------------------------------------------------------

USAGE
}
  if [[ $# -eq 0 ]]; then
    Usage >&2
  else
    stage=${1}

    INPUT_DIR=""
    if [[ ${stage} -eq 1 ]]; then
      INPUT_DIR=${DIR_DATA_HOME}
    elif [[ ${stage} -eq 2 ]]; then
      if [[ -d ${DIR_DATA_DERIV}/pymp2rage ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/pymp2rage
      else
        INPUT_DIR=${DIR_DATA_HOME}
      fi
    elif [[ ${stage} -eq 3 ]]; then
      if [[ -d ${DIR_DATA_DERIV}/denoised ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/denoised
      elif [[ -d ${DIR_DATA_DERIV}/pymp2rage ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/pymp2rage
      else
        INPUT_DIR=${DIR_DATA_HOME}
      fi
    elif [[ ${stage} -eq 4 ]]; then
      if [[ -d ${DIR_DATA_DERIV}/cat12 ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/cat12    
      elif [[ -d ${DIR_DATA_DERIV}/denoised ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/denoised
      elif [[ -d ${DIR_DATA_DERIV}/pymp2rage ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/pymp2rage
      else
        INPUT_DIR=${DIR_DATA_HOME}
      fi    
    elif [[ ${stage} -eq 5 ]]; then
      if [[ -d ${DIR_DATA_DERIV}/masked_${DATA,,} ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/masked_${DATA,,}
      elif [[ -d ${DIR_DATA_DERIV}/cat12 ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/cat12    
      elif [[ -d ${DIR_DATA_DERIV}/denoised ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/denoised
      elif [[ -d ${DIR_DATA_DERIV}/pymp2rage ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/pymp2rage
      else
        INPUT_DIR=${DIR_DATA_HOME}
      fi        
    elif [[ ${stage} -eq 6 ]]; then
      if [[ -d ${DIR_DATA_DERIV}/masked_${DATA,,} ]]; then
        INPUT_DIR=${DIR_DATA_DERIV}/masked_${DATA,,}
      else
        INPUT_DIR=${DIR_DATA_HOME}
      fi           
    else
      echo "ERROR in find_hierarchical_anatomy: invalid stage code \"${stage}\""
    fi

    echo $INPUT_DIR
  fi
}

function search_character_substring {
  input=${1}
  searchstring=${2}
  rest=${input#*$searchstring}
  starts_at=`echo $(( ${#input} - ${#rest} - ${#searchstring} ))`
  echo $starts_at
}

function read_json {

  #---------------------------------------------------------------------------------------------------------
  # Create help text
  function Usage {
      cat <<USAGE

---------------------------------------------------------------------------------------------------
read_json

Read parameters from a json-file. 

Args:
 <json file>  PAR/par file to read
 <read key>   key to read from the json file

Usage:
 read_json some_file.json "RepetitionTime"

---------------------------------------------------------------------------------------------------

USAGE
}

  if [[ $# -lt 2 ]] ; then
    Usage >&2
  else

    json_file=${1}
    read_key=${2}

    if [[ -z ${read_key} ]]; then
      echo "Please specify a key (e.g., \"RepetitionTime\") to read"
    else
      # reads x lines, cuts the :, removes white spaces, and removes carriage return
      json_key=`cat ${json_file} | grep ${read_key} | cut -d':' -f2`
      if [ ! -z ${json_key} ]; then
        if [[ ${json_key} == *","* ]]; then
          json_key=`echo ${json_key} | cut -d"," -f1`
        fi
        json_key=`echo ${json_key} |  xargs | sed 's/\r$//'`
        echo ${json_key}
      else
        echo ""
      fi
    fi
  fi

}

function read_par {

  #---------------------------------------------------------------------------------------------------------
  # Create help text
  function Usage {
      cat <<USAGE

---------------------------------------------------------------------------------------------------
read_par

Read parameters from a PAR-file. 

Args:
 -r <lines>   number of lines to read from the par file (default is 50)
 <par file>   PAR/par file to read
 <read key>   key to read from the par file

Usage:
 read_par some_file.par "EPI factor"

---------------------------------------------------------------------------------------------------

USAGE
}

  if [[ $# -lt 1 ]] ; then
    Usage >&2
  else
    # Check for subject & session flags
    read_lines=50
    par_file=${1}
    if [[ $# -eq 3 ]]; then
      read_lines=${1}
      par_file=${2}
      read_key=${3}
    elif [[ $# -eq 2 ]]; then
      par_file=${1}
      read_key=${2}
    fi

    if [[ -z ${read_key} ]]; then
      echo "Please specify a key (e.g., \"number of echoes\") to read"
    else
      # reads x lines, cuts the :, removes white spaces, and removes carriage return
      par_key=`head -${read_lines} ${par_file} | grep "${read_key}" | cut -d":" -f2 | xargs | sed 's/\r$//'`
      echo ${par_key}
    fi

  fi

}

function add_par_file {

  #---------------------------------------------------------------------------------------------------------
  # Create help text
  function Usage {
      cat <<USAGE

---------------------------------------------------------------------------------------------------
add_par_file

Add the PAR-file to the jsons of newly converted files with dcm2niix. This ensures we retain the 
link with the PAR-file so we can extract information from it

Args:
  pathInput   input directory for dcm2niix; where the par-files live
  pathOutput  output directory for dcm2niix; where the nifti's are stored. If empty, we'll default
              to pathInput/nifti, just like call_dcm2niix

Usage:
 add_par_file input_folder output_folder

---------------------------------------------------------------------------------------------------

USAGE
}

  do_stuff=1
  if [[ $# -lt 1 ]] ; then
    Usage >&2
    do_stuff=0
  elif [[ $# -eq 1 ]]; then
    pathInput=${1}
    pathOutput=${pathInput}/nifti
  elif [[ $# -eq 2 ]]; then
    pathInput=${1}
    pathOutput=${2}  
  fi

  if [[ ${do_stuff} -eq 1 ]]; then
    for ii in ${pathOutput}/*.nii.gz; do
      if [[ $(basename ${ii}) == *"_bold"* || $(basename ${ii}) == *"_epi"* ]]; then
        # cross reference with par files in pathInput
        for par in ${pathInput}/*; do
          ext=`fetch_extension ${par}`
          if [[ ${ext,,} == *"par"* ]]; then
            pat=`read_par ${par} "Patient name"`
            prot=`read_par ${par} "Protocol name"`

            # assuming dcm2niix command above did not change!
            nifti_from_par=${pathOutput}/${pat}_${prot}
            if [[ ${nifti_from_par}.nii.gz -ef ${ii} ]]; then
              call_json ${nifti_from_par}.json ParFile ${par}
            fi
          fi
        done
      fi
    done
  fi

}

function tr_from_par {
  #---------------------------------------------------------------------------------------------------------
  # Create help text
  function Usage {
      cat <<USAGE

---------------------------------------------------------------------------------------------------
tr_from_par

Extract the TR from a PAR-file. This is done by reading the 'dtime' column, getting the 
unique values, then taking the mean (if 'average') over np.diff(), or its first element
('first') 

Args:
  <par file>    PAR/par file to read
  <protocol>    which TR to take: either the average over all TRs ('average'), or the first ('first')

Returns:
  RepetitionTime

Usage:
 tr_from_par some_file.par average [default]
 tr_from_par some_file.par first

---------------------------------------------------------------------------------------------------

USAGE
}

  if [[ $# -lt 1 ]] ; then
    Usage >&2
  else

    par=${1}
    use_case=${2}

    if [[ -z ${use_case} ]]; then
      use_case="average"
    fi

    # fetch where parameters begin
    str="=== IMAGE INFORMATION ="
    line_startpar=`grep -n -m 1 "${str}" ${par} | sed  's/\([0-9]*\).*/\1/'`

    # get TR column
    tr_column=(`sed -n "$((${line_startpar}+2)),$ p" ${par} | awk '{ print $32 }' | sed 's/\r$//'`)

    tr_file=$(dirname ${par})/tr.txt
    if [[ -f ${tr_file} ]]; then
      rm -r ${tr_file}
    fi
    
    # echo list of TRs to tmp file to use np.diff
    echo ${tr_column[@]} >> ${tr_file}

    # define python code
    PYTHON_CODE="""
try:
  import numpy as np;
  trs = np.unique(np.loadtxt('${tr_file}'));
  isi = np.diff(trs);
  if '${use_case}' == 'average': 
    tr = isi.mean();
  else:
    tr = isi[0];
  print(tr);
except:
  print(999);
"""

    # run python code
    tr="$(python -c "$PYTHON_CODE")"

    # remove tmp file
    if [[ -f ${tr_file} ]]; then
      rm -r ${tr_file}
    fi

    echo ${tr}
  fi  
}

function pars_for_json {

  #---------------------------------------------------------------------------------------------------------
  # Create help text
  function Usage {
      cat <<USAGE

---------------------------------------------------------------------------------------------------
pars_for_json

Calculate the following parameters from a PAR-file:
  - Water fat shift (WFS_hz)      | water fat shift*water fat ppm*gyromagnetic ratio
  - Total readout time (TRT)      | water fat shift/WFS_hz
  - Effective echo spacing (EES)  | TRT/EPI factor+1
  - Phase encoding direction      | in fmriprep convention (e.g., AP='j-')
  - MagneticFieldStrength         | default 7.0, can be set with env variable FIELD_STRENGTH
  - EPIFactor                     | -
  - ProtocolName                  | -
  - MultibandAccelerationFactor   | if MB_FACTOR is set in the environment (if scan mode != 3D)
  - Scan mode                     | MS/3D

Args:
  --merge       don't overwrite existing keys
  <par file>    PAR/par file to read
  <json file>   output file; if not specified, the output is printed to the terminal. You can
                choose to redirect this output to another file using 'pars_for_json ... &> some_
                file.txt'

Returns:
  array in the following order: WFS,WFS_hz,TRT,EES,PE

Usage:
 pars_for_json some_file.par

---------------------------------------------------------------------------------------------------

USAGE
}

  if [[ $# -lt 1 ]] ; then
    Usage >&2
  else

    MERGE=""
    par_file=${1}
    if [[ $# -eq 1 ]]; then
      par_file=${1}
      json_file=""
    elif [[ $# -eq 2 ]]; then
      par_file=${1}
      json_file=${2}
    elif [[ $# -eq 3 ]]; then
      par_file=${2}
      json_file=${3}
      MERGE="--merge"
    fi

    # fielstrength
    if [[ -z ${FIELD_STRENGTH} ]]; then
      FIELD_STRENGTH=7.0
    fi
    
    # gyromagnetic ratio
    gyro=42.576

    # water-fat part per million
    wf_ppm=3.35

    # EPI factor
    epi_f=`read_par ${par_file} "EPI factor"`

    # water fat shift
    WFS=`read_par ${par_file} "Water Fat shift"`

    # WFS (freq)
    WFS_hz=`echo "${FIELD_STRENGTH} * ${wf_ppm} * ${gyro}" |bc -l`

    # total read out time
    TRT=`echo "${WFS} / ${WFS_hz}" | bc -l`

    # effective echo spacing (EPI factor +1)
    EES=`echo "${TRT}/(${epi_f}+1)" | bc -l`

    # phase encoding direction; check variable in setup file
    if [ -z ${PE_DIR_BOLD} ]; then
      PE=`read_par ${par_file} "Preparation direction"`
    else
      PE=${PE_DIR_BOLD}
    fi

    ADD_PE=`fprep_pe ${PE}`

    # protocol name
    PROT=`read_par ${par_file} "Protocol name"`

    # EPI factor
    EPI_FACTOR=`read_par ${par_file} "EPI factor"`

    # protocol name
    PROT_NAME=`read_par ${par_file} "Protocol name"`

    # acquisition scheme
    AQ=`read_par ${par_file} "Scan mode"`

    # flip PE if protocol name is BOLD but json file EPI
    txt=""
    if [[ ${PROT} == *"_bold"* ]]; then
      if [[ -f ${json_file} ]]; then
        if [[ $(basename ${json_file}) == *"epi.json"* ]]; then
          ADD_PE=`fprep_pe ${PE} 1`
          txt="flipped for epi_json"
        else
          ADD_PE=`fprep_pe ${PE} 0`
          txt="not flipped"
        fi
      else
        ADD_PE=`fprep_pe ${PE} 0`
        txt="not flipped"
      fi
    elif [[ ${PROT} == *"_epi"* ]]; then
      ADD_PE=`fprep_pe ${PE} 1`
      txt="flipped for epi_json"
    fi

    if [[ ! -z ${json_file} ]]; then
      call_json ${merge} ${json_file} TotalReadoutTime,PhaseEncodingDirection,EffectiveEchoSpacing,ProtocolName,MagneticFieldStrength,WaterFatShift,EPIFactor,ProtocolName,AcquisitionTechnique ${TRT},${ADD_PE},${EES},${PROT},${FIELD_STRENGTH},${WFS},${EPI_FACTOR},${PROT_NAME},${AQ}

      if [[ ! -z ${MB_FACTOR} ]]; then
        if [[ ${AQ} != "3D" ]]; then
          call_json ${json_file} MultiBandAccelerationFactor ${MB_FACTOR}
        fi
      fi
    else
      echo "Field:  ${FIELD_STRENGTH}T"
      echo "WFS:    ${WFS}"
      echo "WFS_hz: ${WFS_hz}"
      echo "TRT:    ${TRT}"
      echo "EES:    ${EES}"
      echo "EPI fc: ${EPI_FACTOR}"
      echo "Prot:   ${PROT_NAME}"
      echo "Mode:   ${AQ}"
      echo "PE:     ${PE} (${ADD_PE}) [${txt}]"
    fi
  fi

}

function fprep_pe {
  PE=${1}
  FLIP=${2}

  # check if we want the flipped version
  if [[ -z ${FLIP} ]]; then
    FLIP=0
  else
    FLIP=${FLIP}
  fi

  # derive code from PE
  if [[ ${PE} == "AP" ]] || [[ ${PE} == "Anterior-Posterior" ]]; then
    if [[ ${FLIP} -eq 0 ]]; then
      ADD_PE="j-"
    else
      ADD_PE="j"
    fi
  elif [[ ${PE} == "PA" ]] || [[ ${PE} == "Posterior-Anterior" ]]; then
    if [[ ${FLIP} -eq 0 ]]; then
      ADD_PE="j"
    else
      ADD_PE="j-"
    fi
  elif [[ ${PE} == "LR" ]] || [[ ${PE} == "Left-Right" ]]; then
    if [[ ${FLIP} -eq 0 ]]; then
      ADD_PE="i"
    else
      ADD_PE="i-"
    fi
  elif [[ ${PE} == "RL" ]] || [[ ${PE} == "Right-Left" ]]; then
    if [[ ${FLIP} -eq 0 ]]; then
      ADD_PE="i-"
    else
      ADD_PE="i"
    fi
  fi

  echo $ADD_PE
}

function add_nordic_msg {

  if [[ $# -ne 2 ]]; then
    echo "Please specify an input folder and the message to add to the json files"
  else
    folder=${1}
    msg=${2}

    if [[ ! -d ${folder} ]]; then
      echo "ERROR: input is not a folder"
    else
      echo "Adding {\"Nordic\": \"${msg}\"} to json-files in \"${folder}\""
      for file in ${folder}/*.json; do
        call_json ${file} "Nordic" "${msg}"
      done
    fi
  fi
}

function fn_exists {

  if [[ $# -eq 0 ]]; then
    echo "ERROR in function: please specify an input"
  else
    func=${1}
    FN=`type -t ${func}`
    if [[ -z ${FN} ]]; then
      echo "Didn't find function \"${func}\""

      if [[ ! -z ${2} ]]; then
        if [[ ${2} -eq 1 ]]; then
          exit 1
        fi
      fi
    fi
  fi
  
}

function check_file {
  input=${1}
  if [ -f ${input} ]; then
    echo "File exists at ${input}"
  elif [ -d ${input} ]; then
    echo "Directory exists at ${input}"
  else
    echo "File/directory \"${input}\" does not exist"
  fi
}

function dykstra_distance {

  if [[ $# -eq 0 ]]; then
    echo
    echo "---------------------------------------------------------------------------------------------------"
    echo "dykstra_distance"
    echo
    echo "Wrapper for mris_pmake. Calculates the distance between <startVertex> & <endVertex> using Dykstra's"
    echo "algorithm."
    echo
    echo "Usage"
    echo "----------"
    echo "  dykstra_distance <subject> <hemi> <surface> <startVertex> <endVertex> <json file>"
    echo ""
    echo "Parameters"
    echo "----------"
    echo "subject: str"
    echo "  subject ID as per FreeSurfer output"
    echo "hemi: str"
    echo "  hemisphere to process. Must be one of \"lh\" or \"rh\""
    echo "surface: str"
    echo "  surface name to process, e.g., \"fiducial\". Defaults to \"inflated\""
    echo "startVertex: int"
    echo "  vertex to calculate distances TO"
    echo "endVertex: int"
    echo "  vertex to calculate distances FROM"
    echo "json file: str"
    echo "  store the output in a key-value pair between <endVertex> and the output from mris_pmake"
    echo ""
    echo "Example"
    echo "----------"
    echo "  dykstra_distance sub-001 lh fiducial 1053 784"
    echo "  dykstra_distance sub-001 lh fiducial 1053 784 sub-001_desc-distances.json"
    echo ""
    echo "---------------------------------------------------------------------------------------------------"
    echo
  else
    dist=`mris_pmake --subject ${1} --hemi ${2} --surface ${3} --mpmProg pathFind --mpmArgs vertexStart:${4},vertexEnd:${5} --mpmOverlay distance | sed -n '2p' | cut -d"[" -f2 | cut -d" " -f2`

    # write output to json file
    if [[ ! -z ${6} ]]; then
      call_json ${6} "${5}" "${dist}"
    else
      echo ${dist}
    fi
  fi
}

function flywheel2bids {
  input_dir=${1}
  fname=${2}
  for ii in ${input_dir}/*.json; do
  
    if [[ ${ii} == *"_ph.json"* ]]; then
      suff="_ph"
    else
      suff=""
    fi

    # get SeriesDescription
    SD=`cat ${ii} | grep "SeriesDescription" | cut -d ":" -f2 | cut -d" " -f2 | cut -d"," -f1 | tr -d '"'`
    outbase=${fname}_${SD}${suff}
    mv ${ii} $(dirname $ii)/${outbase}.json
    mv $(dirname $ii)/$(basename ${ii} .json).nii.gz $(dirname $ii)/${outbase}.nii.gz

  done
} 

function permission_codes {
  stat -c "%a %n" *
}

function delete_prefix {
  for i in "$1"*; do mv "$i" "${i#"$1"}"; done
}

function add_prefix {
  for f in *; do mv "$f" "$1$f"; done
}

function get_id {
  func=$(basename `readlink -f ${1}`)
  tag=${2}
  if [[ ${func} != *"${tag}"* ]]; then
    tag=""
  else
    # need some operations to find the task ID
    part_after_task=${func#*$tag}
    if [[ ! -z ${part_after_task} ]]; then
      # use brute force underscore as delimiter an pray your sequences have been set correctly
      tag=$(echo ${part_after_task} | cut -d'_' -f1 | cut -d"-" -f2)
    else
      # could not derive task; assume its pRF
      tag=""
    fi
  fi

  # get rid of dots by assuming the tag-of-interest precedes dot (lazy solution)
  if [[ ${tag} == *"."* ]]; then
    tag=`echo ${tag} | cut -d"." -f1`
  fi

  echo ${tag}
}

function task_id {
  func=${1}
  task=`get_id ${func} task`
  echo $task
}

function run_id {
  func=${1}
  run=`get_id ${func} run`
  echo $run
}

#start_ssh client
function start_ssh {
  # start the ssh-agent in the background
  eval $(ssh-agent -s)
  # Add a private key to SSH.
  if [ -f ${SSH_KEY} ]; then
    ssh-add ${SSH_KEY}
    ssh -T git@github.com
  else
    echo "${SSH_KEY} key not found!"
  fi
}

function check_function {
  FN=`type -t $1`

  if [[ -z ${FN} ]]; then
    echo 1
  else
    echo 0
  fi
}

# function to wait for a submitted job
function wait_for_qsub {

  if [[ $# -eq 0 ]]; then
    echo
    echo "---------------------------------------------------------------------------------------------------"
    echo "wait_for_qsub"
    echo
    echo "This function waits until the execution of a submitted job has finished before continuing"
    echo
    echo "Usage"
    echo "  wait_for_qsub <job_name>"
    echo
    echo "Examples"
    echo "  wait_for_qsub \"sub-003_all\"    > waits for recon-all for sub-003 to finish"
    echo "---------------------------------------------------------------------------------------------------"
    echo
  else

    # cut job to 9 characters
    PID=$(qstat | grep -A0 "${1}" | awk '{print $1}')
    
    if [[ -z ${PID} ]]; then
      echo "ERROR: could not find job!"
      exit 1
    fi

    # PID=$(qstat | grep -A0 "qsub_test" | awk '{print $1}')
    echo "Waiting for job to finish.."
    while true; do
      JOBRUNNING=$(qstat -u "`whoami`" | awk '$1 == '"${PID}"'' | wc -l)
      if [[ ${JOBRUNNING} == "0" ]]; then
        echo "Job done"
        break
      fi
    done
  fi

}


# function to fetch the module number given a string. Easy if you do remember the name of the process, but not
# the associated module number
function get_module_nr() {

  if [[ $# -eq 0 ]]; then
    echo "NEED AT LEAST ONE ARGUMENT!"
    echo
    echo "---------------------------------------------------------------------------------------------------"
    echo "get_module_nr"
    echo
    echo "Function to get the module number given an input string. It reads the help-text of the master script"
    echo "in linescanning/shell/master from line 56 to 100 and looks for the module corresponding to the input"
    echo "string. I have this because module numbers tend to change and I don't feel like looking that up every"
    echo "time.."
    echo
    echo "The more specific you are with your string, the more stable the result will be. Important is that the"
    echo "format as specified in the master-script is maintained. This is because it looks for the leading semi-"
    echo "colon and certain spaces. So if you add modules to the help text, use the format that you see in there!"
    echo
    echo "Usage"
    echo "  get_module_nr <string1>"
    echo
    echo "Examples"
    echo "  get_module_nr \"spinoza_fmriprep\"    > fetches the module number of fmriprep"
    echo "  get_module_nr \"spinoza_freesurfer\"  > fetches the module number of freesurfer"
    echo "---------------------------------------------------------------------------------------------------"
    echo
  else
    # Function to fetch the module number by reading the 'help' info from the master-script. It
    # accepts a string to look for as argument.
    start=`sed -n '/Available modules/=' ${DIR_SCRIPTS}/shell/master`
    end=`sed -n '/--END--/=' ${DIR_SCRIPTS}/shell/master`
    mods=`sed -n "${start},${end}p" ${DIR_SCRIPTS}/shell/master | grep -A0 "${1}"  | awk '{print $1}' | cut -d"-" -f2 | cut -d':' -f1`

    # store in array and sort
    IFS=$'\n' mods_sort=($(sort <<<"${mods[*]}"))
    unset IFS
    echo ${mods_sort[@]}
  fi

}

# get extension from file
function fetch_extension {
  fname=$(basename -- "${1}")
  ext="${fname##*.}"
  filename="${fname%.*}"
  echo $ext
}

# function to get whole file path
function fetch_filepath {

  # if file specified is in current directory, add entire path
  if [[ `echo ${1:0:1}` != "/" ]]; then
    INPUT=`readlink -f ${1}`
  else
    INPUT=${1}
  fi

  echo ${INPUT}
}

#-----------------------------------------------------------------------------
# Define function to call matlab given a script
function call_matlab {

  if [[ $# -ne 1 ]]; then
    echo "Received 0 arguments, need the path to the matlab script"
    echo
    echo "---------------------------------------------------------------------------------------------------"
    echo "call_matlab"
    echo
    echo "Wrapper to call matlab from the command line. It'll need a full path to the script and will read"
    echo "from the SKIP_LINES variable how many lines should be skipped during start up. Seeing all those"
    echo "module that are added is rather redundant."
    echo
    echo "Usage:"
    echo "  call_matlab <string_to_matlab_script>"
    echo
    echo "Examples:"
    echo "  call_matlab /path/to/my/matlab_script.m"
    echo "---------------------------------------------------------------------------------------------------"
    echo
  else
    if [[ ! -z ${SKIP_LINES} ]]; then
      skip_lines=${SKIP_LINES}
    else
      skip_lines=0
    fi

    MATLAB_SCRIPT=`fetch_filepath ${1}`
    ${MATLAB_CMD} "addpath('$(dirname ${MATLAB_SCRIPT})'); $(basename ${MATLAB_SCRIPT} .m)" | tail -n +${skip_lines} # suppress intro text
    if [[ $? -ne 0 ]]; then
      exit 1
    fi
  fi  
}

#-----------------------------------------------------------------------------
# SANLM script
function make_sanlm_script {

  if [[ $# -ne 3 ]]; then
    echo "Received only ${#} arguments, need 3:"
    count=0; for ii in "${@}"; do ((count++)); echo " ${count}.) ${ii}"; done
    echo
    echo "---------------------------------------------------------------------------------------------------"
    echo "make_sanlm_script"
    echo
    echo "Make a matlab script to be called with call_matlab to denoise your images with the SANLM-filter".
    echo "This spatial-adaptive Non-Local Means (SANLM) is a denoising filter and removes noise while maintai-"
    echo "ning edges, making this more suited than Gaussian filtering methods that blur the images."
    echo ""
    echo "The NL-means filter (7) restores every pixel in the image by computing a weighted average of sur-"
    echo "rounding pixels using a robust similarity measure that takes into account the neighboring pixels sur-"
    echo "rounding the pixel being compared. The most important parameter for NL-means denoising is h2, which "
    echo "regulates the smoothing strength. The optimum value of this parameter has been experimentally esti-"
    echo "mated to be σ2 for the block-based NL-means version, σ being the noise standard deviation"
    echo "module that are added is rather redundant."
    echo "See: https://onlinelibrary.wiley.com/doi/10.1002/jmri.22003"
    echo ""
    echo "Args:"
    echo "  <spm_path>  path to the desired SPM-installation"
    echo "  <input>     input image (gunzip'ed nii-file)"
    echo "  <script>    script name"
    echo ""
    echo "Usage:"
    echo "  make_sanlm_script <path/to/spm12> <anat.nii> <string_to_matlab_script>"
    echo
    echo "Examples:"
    echo "  make_sanlm_script /usr/bin/spm12 anat.nii.gz /path/to/my/matlab_script.m"
    echo "---------------------------------------------------------------------------------------------------"
    echo
  else  

    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. SANLM-filtering with CAT12"
    echo ""
    echo "clear;"
    echo "addpath(genpath('${1}'));"
    echo "matlabbatch{1}.spm.tools.cat.tools.sanlm.data = {'${2},1'};"
    echo "matlabbatch{1}.spm.tools.cat.tools.sanlm.prefix = 'sanlm_';"
    echo "matlabbatch{1}.spm.tools.cat.tools.sanlm.NCstr = Inf;"
    echo "matlabbatch{1}.spm.tools.cat.tools.sanlm.rician = 0;"
    echo ""
    echo "spm_jobman('initcfg');"
    echo "spm('defaults','fMRI')"
    echo "spm_jobman('run', matlabbatch);"
    echo "exit"
    ) >> ${3}

  fi

}

#-----------------------------------------------------------------------------
# SUIT SCRIPT
function make_suit_script {

  if [[ $# -ne 3 ]]; then
    echo "Received only ${#} arguments, need 3:"
    count=0; for ii in "${@}"; do ((count++)); echo " ${count}.) ${ii}"; done
    echo
    echo "---------------------------------------------------------------------------------------------------"
    echo "make_suit_script"
    echo
    echo "Make a matlab script to be called with call_matlab to segment the cerebellum".
    echo ""
    echo "Args:"
    echo "  <spm_path>  path to the desired SPM-installation"
    echo "  <input>     input image (gunzip'ed nii-file)"
    echo "  <script>    script name"
    echo ""
    echo "Usage:"
    echo "  make_suit_script <path/to/spm12> <anat.nii> <string_to_matlab_script>"
    echo
    echo "Examples:"
    echo "  make_suit_script /usr/bin/spm12 anat.nii /path/to/my/matlab_script.m"
    echo "---------------------------------------------------------------------------------------------------"
    echo
  else

    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. Cerebellum segmentation with SUIT"
    echo ""
    echo "clear;"
    echo "addpath(genpath('${1}'));"
    echo "matlabbatch{1}.spm.tools.suit.isolate_seg.source = {{'${2},1'}};"
    echo "matlabbatch{1}.spm.tools.suit.isolate_seg.bb = [-76 76"
    echo "                                                -108 -6"
    echo "                                                -70 11];"
    echo "matlabbatch{1}.spm.tools.suit.isolate_seg.maskp = 0.2;"
    echo "matlabbatch{1}.spm.tools.suit.isolate_seg.keeptempfiles = 1;"
    echo ""
    echo "spm_jobman('initcfg');"
    echo "spm('defaults','fMRI')"
    echo "spm_jobman('run', matlabbatch);"
    echo "exit"
    ) >> ${3}
  fi

}

#-----------------------------------------------------------------------------
# NORDIC SCRIPT
function make_nordic_script {
  if [[ $# -ne 5 ]]; then
    echo "Received only ${#} arguments, need 4:"
    count=0; for ii in "${@}"; do ((count++)); echo " ${count}.) ${ii}"; done
    echo
    echo "---------------------------------------------------------------------------------------------------"
    echo "make_nordic_script"
    echo
    echo "Make a matlab script to be called with call_matlab to run NORDIC. If you want to change the mode to"
    echo "\"magnitude-only\", set the \"ARG.magnitude_only\" to 1. Default = [], which includes the phase data."
    echo ""
    echo "Args:"
    echo "  <magnitude> path to magnitude image of fMRI-acquisition"
    echo "  <phase>     path to phase image of fMRI-acquisition"
    echo "  <output>    path to NORDIC'ed output"
    echo "  <mag_only>  1 for magnitude only; [] for magnitude & phase"
    echo "  <script>    script name"
    echo ""
    echo "Usage:"
    echo "  make_nordic_script <mag> <phase> <output> <script>"
    echo
    echo "Examples:"
    echo "  make_nordic_script mag.nii.gz phase.nii.gz nordic.nii.gz nordic.m"
    echo "---------------------------------------------------------------------------------------------------"
    echo
  else  

    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. Nordic on $(basename ${1})"
    echo ""
    echo "clear;"
    echo "addpath(genpath('${DIR_SCRIPTS}/misc'));"
    echo "ARG.DIROUT              = '$(dirname ${3})/';"
    # echo "ARG.temporal_phase      = 1;"
    # echo "ARG.phase_filter_width  = 10;"
    echo "ARG.magnitude_only      = ${4};"
    echo ""
    echo "nordic_template('${1}', '${2}', '$(basename ${3})', ARG);"
    echo ""
    echo "exit;"
    ) >> ${5}

  fi

}

#-----------------------------------------------------------------------------
# ANTs RF SCRIPT (MNI>FSAverage)
function make_antsrf_script {
  function Usage {
    cat <<USAGE

---------------------------------------------------------------------------------------------------
make_antsrf_script

Follow workflow https://mumfordbrainstats.tumblr.com/post/166054797696/feat-registration-workaround
To use fMRIprep output in FEAT. Uses the mean of the functional run as 'standard', rather than the
MNI152-image.

Args:
  <input>        input file that needs to be warped
  <interp>       interpolation method (linear or nearest, default is linear)
  <output dir>   output directory (defaults to SUBJECTS_DIR/fsaverage/surf)
  <basename>     output basename (defaults to 'mni2fsaverage')
  <script>       name for the script

Example:
  make_antsrf_script zstats1.nii.gz "linear" some/dir desc-zstats1 sub-01_ses-1_desc-antsrf.m

---------------------------------------------------------------------------------------------------

USAGE
}

  in_file=`readlink -f ${1}`
  interp=${2}
  output_dir=${3}
  base_name=${4}
  script_name=${5}
  
  if [[ ${HELP} -eq 1 || $# -lt 5 ]]; then
    Usage >&2
  else

    # set default output directory
    if [[ -z ${output_dir} ]]; then
      output_dir=${FS}/fsaverage/surf
    fi

    # create it if it doesn't exit
    if [[ ! -d ${output_dir} ]]; then
      mkdir -p ${output_dir}
    fi

    # set default basename
    if [[ -z ${base_name} ]]; then
      base_name="mni2fsaverage"
    fi

    # set default basename
    if [[ -z ${script_name} ]]; then
      script_name=$(dirname ${in_file})/$(basename ${in_file} .nii.gz).m
    fi

    # output files
    lh_output=${output_dir}/lh.${base_name}.nii.gz
    rh_output=${output_dir}/rh.${base_name}.nii.gz

    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. Projecting $(basename ${in_file}) to FSAverage"
    echo ""
    echo "clear;"
    echo "addpath(genpath('${DIR_SCRIPTS}/misc'));"
    echo "lh_map = '${DIR_SCRIPTS}/misc/CBIG_lh.avgMapping_allSub_RF_ANTs_MNI152_orig_to_fsaverage.mat';"
    echo "rh_map = '${DIR_SCRIPTS}/misc/CBIG_rh.avgMapping_allSub_RF_ANTs_MNI152_orig_to_fsaverage.mat';"
    echo "input = MRIread('${in_file}');"
    echo "[lh_proj_data, rh_proj_data] = CBIG_RF_projectMNI2fsaverage('${in_file}', '${interp}', lh_map, rh_map);"
    echo ""
    echo "input.vol = permute(lh_proj_data, [4 2 3 1]);"
    echo "MRIwrite(input, '${lh_output}');"
    echo "input.vol = permute(rh_proj_data, [4 2 3 1]);"
    echo "MRIwrite(input, '${rh_output}');"
    echo ""
    echo "exit;"
    ) >> ${script_name}

  fi

}

#-----------------------------------------------------------------------------
# Define function to create SPM-compatible script with
function make_bias_script {

  if [[ $# -ne 3 ]]; then
    echo "Received only ${#} arguments, need 3:"
    count=0; for ii in "${@}"; do ((count++)); echo " ${count}.) ${ii}"; done
    echo
    echo "---------------------------------------------------------------------------------------------------"
    echo "make_bias_script"
    echo
    echo "Make a matlab script to be called with call_matlab to bias correct your image with SPM".
    echo ""
    echo "Args:"
    echo "  <spm_path>  path to the desired SPM-installation"
    echo "  <input>     input image (gunzip'ed nii-file)"
    echo "  <script>    script name"
    echo ""
    echo "Usage:"
    echo "  make_bias_script <path/to/spm12> <anat.nii> <string_to_matlab_script>"
    echo
    echo "Examples:"
    echo "  make_bias_script /usr/bin/spm12 anat.nii /path/to/my/matlab_script.m"
    echo "---------------------------------------------------------------------------------------------------"
    echo
  else
    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. Bias field correction with SPM12"
    echo ""
    echo "clear;"
    echo "addpath(genpath('${1}'));"
    echo "matlabbatch{1}.spm.spatial.preproc.channel.vols = {'${2},1'};"
    echo "matlabbatch{1}.spm.spatial.preproc.channel.biasreg = 0.001;"
    echo "matlabbatch{1}.spm.spatial.preproc.channel.biasfwhm = 60;"
    echo "matlabbatch{1}.spm.spatial.preproc.channel.write = [1 1];"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(1).tpm = {'${1}/tpm/TPM.nii,1'};"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(1).ngaus = 1;"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(1).native = [0 0];"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(1).warped = [0 0];"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(2).tpm = {'${1}/tpm/TPM.nii,2'};"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(2).ngaus = 1;"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(2).native = [0 0];"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(2).warped = [0 0];"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(3).tpm = {'${1}/tpm/TPM.nii,3'};"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(3).ngaus = 2;"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(3).native = [0 0];"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(3).warped = [0 0];"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(4).tpm = {'${1}/tpm/TPM.nii,4'};"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(4).ngaus = 3;"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(4).native = [0 0];"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(4).warped = [0 0];"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(5).tpm = {'${1}/tpm/TPM.nii,5'};"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(5).ngaus = 4;"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(5).native = [0 0];"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(5).warped = [0 0];"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(6).tpm = {'${1}/tpm/TPM.nii,6'};"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(6).ngaus = 2;"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(6).native = [0 0];"
    echo "matlabbatch{1}.spm.spatial.preproc.tissue(6).warped = [0 0];"
    echo "matlabbatch{1}.spm.spatial.preproc.warp.mrf = 1;"
    echo "matlabbatch{1}.spm.spatial.preproc.warp.cleanup = 0;"
    echo "matlabbatch{1}.spm.spatial.preproc.warp.reg = [0 0.001 0.5 0.05 0.2];"
    echo "matlabbatch{1}.spm.spatial.preproc.warp.affreg = 'mni';"
    echo "matlabbatch{1}.spm.spatial.preproc.warp.fwhm = 0;"
    echo "matlabbatch{1}.spm.spatial.preproc.warp.samp = 3;"
    echo "matlabbatch{1}.spm.spatial.preproc.warp.write = [0 0];"
    echo ""
    echo "spm_jobman('initcfg');"
    echo "spm('defaults','fMRI')"
    echo "spm_jobman('run', matlabbatch);"
    echo "exit"
    ) >> ${3}
  fi
}


#-----------------------------------------------------------------------------
# PHYSIO SCRIPT
function make_physio_script {

  if [[ $# -ne 8 ]]; then
    echo "Received only ${#} arguments, need 8:"
    count=0; for ii in "${@}"; do ((count++)); echo " ${count}.) ${ii}"; done
    echo
    echo "---------------------------------------------------------------------------------------------------"
    echo "make_physio_script"
    echo ""
    echo "Make a matlab script to be called with call_matlab to create regressor files from your physio recor-"
    echo "dings from the scanner using the PhysIO-toolbox as part of TAPAS"
    echo ""
    echo "Args:"
    echo "  <spm_path>  path to the desired SPM-installation"
    echo "  <input>     input file; assumed to be the output from \"scanphyslog2bids\" (.tsv.gz-file)"
    echo "  <tr>        repetition time of acquisition"
    echo "  <volumes>   number of volumes in the functional run"
    echo "  <output>    directory+basename for output files (extensions will be appended)"
    echo "  <dummies>   number of dummy volumes"
    echo "  <n_slices>  number of slices in the volume"
    echo "  <script>    script name"
    echo ""
    echo "Usage:"
    echo "  make_physio_script <path/to/spm12> <physio.tsv.gz> <tr> <volumes> <output> <string_to_matlab_script>"
    echo ""
    echo "Examples:"
    echo "  make_physio_script /usr/bin/spm12 anat.nii 0.105 3200 regressors /path/to/my/matlab_script.m"
    echo "---------------------------------------------------------------------------------------------------"
    echo
  else

    ext=`fetch_extension ${2}`
    if [[ ${ext,,} == "log" ]]; then
      vendor="philips"
    else
      vendor="BIDS"
    fi

    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. Create PhysIO regressors from SCANPHYSLOG"
    echo ""
    echo "clear;"
    echo "addpath(genpath('${1}'));"
    echo "matlabbatch{1}.spm.tools.physio.save_dir = {''};"
    echo "matlabbatch{1}.spm.tools.physio.log_files.vendor = '${vendor}';"
    echo "matlabbatch{1}.spm.tools.physio.log_files.cardiac = {'${2}'};"
    echo "matlabbatch{1}.spm.tools.physio.log_files.respiration = {'${2}'};"
    echo "matlabbatch{1}.spm.tools.physio.log_files.scan_timing = {''};"
    echo "matlabbatch{1}.spm.tools.physio.log_files.sampling_interval = [];"
    echo "matlabbatch{1}.spm.tools.physio.log_files.relative_start_acquisition = 0;"
    echo "matlabbatch{1}.spm.tools.physio.log_files.align_scan = 'first';"
    echo "matlabbatch{1}.spm.tools.physio.scan_timing.sqpar.Nslices = ${7};"
    echo "matlabbatch{1}.spm.tools.physio.scan_timing.sqpar.NslicesPerBeat = [];"
    echo "matlabbatch{1}.spm.tools.physio.scan_timing.sqpar.TR = ${3};"
    echo "matlabbatch{1}.spm.tools.physio.scan_timing.sqpar.Ndummies = ${6};"
    echo "matlabbatch{1}.spm.tools.physio.scan_timing.sqpar.Nscans = ${4};"
    echo "matlabbatch{1}.spm.tools.physio.scan_timing.sqpar.onset_slice = 1;"
    echo "matlabbatch{1}.spm.tools.physio.scan_timing.sqpar.time_slice_to_slice = [];"
    echo "matlabbatch{1}.spm.tools.physio.scan_timing.sqpar.Nprep = [];"
    echo "matlabbatch{1}.spm.tools.physio.scan_timing.sync.nominal = struct([]);"
    echo "matlabbatch{1}.spm.tools.physio.preproc.cardiac.modality = 'PPU';"
    echo "matlabbatch{1}.spm.tools.physio.preproc.cardiac.filter.no = struct([]);"
    echo "matlabbatch{1}.spm.tools.physio.preproc.cardiac.initial_cpulse_select.auto_matched.min = 0.4;"
    echo "matlabbatch{1}.spm.tools.physio.preproc.cardiac.initial_cpulse_select.auto_matched.file = 'initial_cpulse_kRpeakfile.mat';"
    echo "matlabbatch{1}.spm.tools.physio.preproc.cardiac.initial_cpulse_select.auto_matched.max_heart_rate_bpm = 90;"
    echo "matlabbatch{1}.spm.tools.physio.preproc.cardiac.posthoc_cpulse_select.off = struct([]);"
    echo "matlabbatch{1}.spm.tools.physio.model.output_multiple_regressors = '${5}.tsv';"
    echo "matlabbatch{1}.spm.tools.physio.model.output_physio = '${5}.mat';"
    echo "matlabbatch{1}.spm.tools.physio.model.orthogonalise = 'none';"
    echo "matlabbatch{1}.spm.tools.physio.model.censor_unreliable_recording_intervals = false;"
    echo "matlabbatch{1}.spm.tools.physio.model.retroicor.yes.order.c = 3;"
    echo "matlabbatch{1}.spm.tools.physio.model.retroicor.yes.order.r = 4;"
    echo "matlabbatch{1}.spm.tools.physio.model.retroicor.yes.order.cr = 1;"
    echo "matlabbatch{1}.spm.tools.physio.model.rvt.yes.delays = 0;"
    echo "matlabbatch{1}.spm.tools.physio.model.hrv.yes.delays = 0;"
    echo "matlabbatch{1}.spm.tools.physio.model.noise_rois.no = struct([]);"
    echo "matlabbatch{1}.spm.tools.physio.model.movement.no = struct([]);"
    echo "matlabbatch{1}.spm.tools.physio.model.other.no = struct([]);"
    echo "matlabbatch{1}.spm.tools.physio.verbose.level = 0;"
    echo "matlabbatch{1}.spm.tools.physio.verbose.fig_output_file = '';"
    echo "matlabbatch{1}.spm.tools.physio.verbose.use_tabs = false;"
    echo ""
    echo "spm_jobman('initcfg');"
    echo "spm('defaults','fMRI')"
    echo "spm_jobman('run', matlabbatch);"
    echo "exit"
    ) >> ${8}

    cat ${8} | grep -A0 "matlabbatch{" >> $(dirname ${8})/$(basename ${8} .m)_batch.m

  fi
  
}

#-----------------------------------------------------------------------------
# SPM BRAIN MASK SCRIPT
function make_mask_script {

  if [[ $# -ne 3 ]]; then
    echo "Received only ${#} arguments, need 3:"
    count=0; for ii in "${@}"; do ((count++)); echo " ${count}.) ${ii}"; done
    echo
    echo "---------------------------------------------------------------------------------------------------"
    echo "make_mask_script"
    echo
    echo "Make a matlab script to be called with call_matlab to create a brain mask from the INV2 image"
    echo ""
    echo "Args:"
    echo "  <spm_path>  path to the desired SPM-installation"
    echo "  <input>     input image (gunzip'ed nii-file), generally the INV2 image of an MP2RAGE sequence"
    echo "  <script>    script name"
    echo ""
    echo "Usage:"
    echo "  make_mask_script <path/to/spm12> <inv2.nii> <string_to_matlab_script>"
    echo
    echo "Examples:"
    echo "  make_mask_script /usr/bin/spm12 inv2.nii /path/to/my/matlab_script.m"
    echo "---------------------------------------------------------------------------------------------------"
    echo
  else

    (
    echo "%-----------------------------------------------------------------------------"
    echo "% Created on `date`. spmBrainMask on INV-2 image"
    echo ""
    echo "clear;"
    echo "addpath(genpath('${DIR_SCRIPTS}/misc'));"
    echo "addpath(genpath('${1}'));"
    echo ""
    echo "niifile = '${2}';"
    echo "maskfile=spmBrainMask(niifile);"
    echo ""
    echo "exit;"
    ) >> ${3}
    
  fi
}


#-----------------------------------------------------------------------------
# CAT12 SCRIPT
function make_cat_script {
  if [[ $# -ne 4 ]]; then
    echo "Received only ${#} arguments, need 4:"
    count=0; for ii in "${@}"; do ((count++)); echo " ${count}.) ${ii}"; done
    echo
    echo "---------------------------------------------------------------------------------------------------"
    echo "make_cat_script"
    echo
    echo "Make a matlab script to be called with call_matlab to segment your anatomical file with CAT12. Can"
    echo "also do denoising and stuff, but better and more conservative to do this with call_spmsanlm"
    echo ""
    echo "Args:"
    echo "  <spm_path>  path to the desired SPM-installation"
    echo "  <input>     input image (gunzip'ed nii-file)"
    echo "  <mode>      \"brain\" for just segmentations; \"full\" for intensity normalization & SANLM-filtering"
    echo "  <script>    script name"
    echo ""
    echo "Usage:"
    echo "  make_cat_script <path/to/spm12> <anat.nii> <mode> <string_to_matlab_script>"
    echo
    echo "Examples:"
    echo "  make_cat_script /usr/bin/spm12 anat.nii brain /path/to/my/matlab_script.m"
    echo "---------------------------------------------------------------------------------------------------"
    echo
    exit 1
  fi

  # Check if we have compatible version; we're using 12.6!!
  VER=`cat ${1}/toolbox/cat12/Contents.txt | grep Version | cut -d" " -f3 2>/dev/null`
  if [[ ${VER} != "1113" && ${VER} != "1450" && ${VER} != "2043" ]]; then
    echo "CAT12 VERSION = ${VER}: I only have support for CAT12 (r1113), CAT12.6 (r1450), or CAT12.8 (r2043)"
    exit 1
  fi

  cat12_dir=`find ${1} -type d -name "*cat12*" -print -quit 2>/dev/null`
  if [[ -z ${cat12_dir} ]]; then
    echo "Could not find CAT12-directory in \"${1}\""
    exit 1
  fi

  tpm_dir=`find $(dirname ${1}) -type d -name "*tpm*" -print -quit 2>/dev/null`
  if [[ -z ${tpm_dir} ]]; then
    echo "Could not find template-directory in \"${1})\""
    exit 1
  fi

  if [[ ${PLACE} == "SGE" ]]; then
    CPUs=0
  else
    CPUs=0
  fi

  (
  echo "%-----------------------------------------------------------------------------"
  echo "% Created on `date`. Running with ${VER}"
  echo ""
  echo "clear;"
  echo "addpath(genpath('${1}'));"
  echo ""
  echo "matlabbatch{1}.spm.tools.cat.estwrite.data = {'${2},1'};"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.nproc = ${CPUs};"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.opts.tpm = {'${1}/tpm/TPM.nii'};"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.opts.affreg = 'mni';"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.GM.native = 1;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.GM.warped = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.GM.mod = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.GM.dartel = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.WM.native = 1;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.WM.warped = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.WM.mod = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.WM.dartel = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.CSF.native = 1;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.CSF.warped = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.CSF.mod = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.CSF.dartel = 0;"  
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.WMH.native = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.WMH.warped = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.WMH.mod = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.WMH.dartel = 0;" 
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.label.native = 1;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.label.warped = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.label.dartel = 0;"   
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.surface = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.bias.native = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.bias.warped = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.bias.dartel = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.las.native = 1;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.las.warped = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.las.dartel = 0;"
  echo "matlabbatch{1}.spm.tools.cat.estwrite.output.warps = [0 0];"
  ) >> ${4}

  if [[ ${3} == 'brain' ]]; then
    echo "Turning off bias/intensity correction & sanlm-filtering"
    bias_reg=0
    bias_fhwm="Inf"
    app=0
    sanlm=0
  else
    bias_reg=0.001
    bias_fhwm=60
    app=2
    sanlm=2
  fi

  if [[ ${VER} == "1113" ]]; then

    (
    echo "matlabbatch{1}.spm.tools.cat.estwrite.opts.ngaus = [1 1 2 3 4 2];"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.opts.biasreg = ${bias_reg};"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.opts.biasfwhm = ${bias_fhwm};"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.opts.warpreg = [0 0.001 0.5 0.05 0.2];"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.opts.samp = 3;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.APP = ${app};"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.sanlm = ${sanlm};"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.NCstr = -Inf;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.LASstr = 0.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.gcutstr = 0.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.cleanupstr = 0.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.regstr = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.WMHCstr = 0.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.WMHC = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.darteltpm = {'${1}/toolbox/cat12/templates_1.50mm/Template_1_IXI555_MNI152.nii'};"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.restypes.native = struct([]);"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.vox = 1.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.pbtres = 0.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.scale_cortex = 0.7;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.add_parahipp = 0.1;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.ignoreErrors = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.ROI = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.atlases.neuromorphometrics = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.atlases.lpba40 = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.atlases.cobra = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.atlases.hammers = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.jacobian.warped = 0;"
    ) >> ${4}

  elif [[ ${VER} == "1450" ]]; then
    (
    echo "matlabbatch{1}.spm.tools.cat.estwrite.opts.affreg = 'mni';"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.opts.biasstr = 0.75;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.opts.accstr = 0.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.APP = 1070;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.NCstr = -Inf;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.LASstr = 0.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.gcutstr = 2;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.cleanupstr = 0.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.WMHC = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.SLC = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.restypes.native = struct([]);"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.registration.dartel.darteltpm = {'${1}/toolbox/cat12/templates_1.50mm/Template_1_IXI555_MNI152.nii'};"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.vox = 1.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.surface.pbtres = 0.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.surface.scale_cortex = 0.7;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.surface.add_parahipp = 0.1;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.surface.close_parahipp = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.admin.ignoreErrors = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.admin.verb = 2;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.admin.print = 2;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.surface = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.ROImenu.noROI = struct([]);"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.SL.native = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.SL.warped = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.SL.mod = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.SL.dartel = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.atlas.native = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.atlas.dartel = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.jacobianwarped = 0;"
    ) >> ${4}

  elif [[ ${VER} == "2043" ]]; then
    (
    echo "matlabbatch{1}.spm.tools.cat.estwrite.data_wmh = {''};"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.useprior = '';"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.opts.biasstr = eps;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.opts.accstr = 0.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.restypes.native = struct([]);"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.setCOM = 1;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.APP = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.affmod = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.NCstr = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.spm_kamap = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.LASstr = 0.75;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.LASmyostr = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.gcutstr = 2;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.cleanupstr = 0.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.BVCstr = 0.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.WMHC = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.SLC = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.segmentation.mrf = 1;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.registration.regmethod.shooting.shootingtpm = {'${1}/toolbox/cat12/templates_MNI152NLin2009cAsym/Template_0_GS.nii'};"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.registration.regmethod.shooting.regstr = 0.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.registration.vox = 1;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.registration.bb = 12;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.surface.pbtres = 0.5;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.surface.pbtmethod = 'pbt2x';"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.surface.SRP = 22;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.surface.reduce_mesh = 1;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.surface.vdist = 2;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.surface.scale_cortex = 0.7;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.surface.add_parahipp = 0.1;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.surface.close_parahipp = 1;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.admin.experimental = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.admin.new_release = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.admin.lazy = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.admin.ignoreErrors = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.admin.verb = 2;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.extopts.admin.print = 1;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.BIDS.BIDSno = 1;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.surf_measures = 1;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.ROImenu.noROI = struct([]);"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.ct.native = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.ct.warped = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.ct.dartel = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.pp.native = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.pp.warped = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.pp.dartel = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.SL.native = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.SL.warped = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.SL.mod = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.SL.dartel = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.TPMC.native = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.TPMC.warped = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.TPMC.mod = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.TPMC.dartel = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.atlas.native = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.labelnative = 1;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.jacobianwarped = 0;"
    echo "matlabbatch{1}.spm.tools.cat.estwrite.output.rmat = 0;"
  ) >> ${4}
  fi

  (
  echo ""
  echo "cat_get_defaults('extopts.expertgui',1);"
  echo "spm_jobman('initcfg');"
  echo "spm('defaults','fMRI')"
  echo "spm_jobman('run', matlabbatch);"
  echo "exit"
  ) >> ${4}

  # also save the matlabbatch-only lines to a file that we can load in SPM/CAT12
  if [[ -f $(dirname ${4})/$(basename ${4} .m)_batch.m ]]; then
    rm $(dirname ${4})/$(basename ${4} .m)_batch.m
  fi

  cat ${4} | grep -A0 "matlabbatch{" >> $(dirname ${4})/$(basename ${4} .m)_batch.m

}


#-----------------------------------------------------------------------------
# HTML started mimicking fMRIprep
function make_html_start {

  cat > ${1} << EOF

<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title></title>
<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
<style type="text/css">
.sub-report-title {}
.run-title {}

h1 { padding-top: 35px; }
h2 { padding-top: 20px; }
h3 { padding-top: 15px; }

.elem-desc {}
.elem-caption {
    margin-top: 15px
    margin-bottom: 0;
}
.elem-filename {}

div.elem-image {
  width: 100%;
  page-break-before:always;
}

.elem-image object.svg-reportlet {
    width: 100%;
    padding-bottom: 5px;
}
body {
    padding: 65px 10px 10px;
}

.boiler-html {
    font-family: "Bitstream Charter", "Georgia", Times;
    margin: 20px 25px;
    padding: 10px;
    background-color: #F8F9FA;
}

div#boilerplate pre {
    margin: 20px 25px;
    padding: 10px;
    background-color: #F8F9FA;
}

#errors div, #errors p {
    padding-left: 1em;
}
</style>
</head>
<body>


<nav class="navbar fixed-top navbar-expand-lg navbar-light bg-light">
<div class="collapse navbar-collapse">
    <ul class="navbar-nav">
        <li class="nav-item"><a class="nav-link" href="#Summary">Summary</a></li>
        <li class="nav-item"><a class="nav-link" href="#Anatomical">Anatomical</a></li>
    </ul>
</div>
</nav>
<noscript>
    <h1 class="text-danger"> The navigation menu uses Javascript. Without it this report might not work as expected </h1>
</noscript>

    <div id="Summary">
    <h1 class="sub-report-title">Summary</h1>
        <div id="datatype-figures_desc-summary_suffix-T1w">
                    <ul class="elem-desc">
		<li>Structural images: 1 T1-weighted </li>
		<li>FreeSurfer reconstruction: Run by fMRIPrep</li>
	</ul>
        </div>
    </div>
    <div id="Anatomical">

EOF

}


function make_html_end {

  cat >> ${1} << EOF

        </div>
        <div id="datatype-figures_regex_search-True_space-.*_suffix-T1w">

<script type="text/javascript">
    function toggle(id) {
        var element = document.getElementById(id);
        if(element.style.display == 'block')
            element.style.display = 'none';
        else
            element.style.display = 'block';
    }
</script>
</body>
</html>

EOF
}

function scanner_v_itksnap {

    cat <<USAGE

SCANNER VS ITKSNAP SOFTWARE ANGLES
--------------------------------------------------------------------------------------------------------
Translation values:
    ________|__ITKSNAP________________________________|__SCANNER_______________________________
    X (LR)  |  R = +mm (R = pos; L is neg)            |  L = +mm (R = neg; L = pos)
    Y (AP)  |  A = +mm (A = pos; P = neg)             |  P = +mm (A = neg; P = pos)
    Z (FH)  |  F = +mm (F = pos; H = neg)             |  H = +mm (F = neg; H = pos)

Orientation values:
    ________|__ITKSNAP________________________________|__SCANNER_______________________________
    X (LR)  |  neg = counterclock; pos = clockwise    |  neg = clockwise;    pos = counterclock
    Y (AP)  |  neg = clockwise;    pos = counterclock |  neg = counterclock; pos = clockwise
    Z (FH)  |  neg = clockwise;    pos = counterclock |  neg = counterclock; pos = clockwise

As you can see, the values are interpreted inversely, meaning we need to flip the signs of the rotation
and translation if we want values corresponding to scanner customs.

Another important note to make: the voxel values from coordinates.csv are indexed starting from 0.
Other software packages, such as ITKSNAP indexes starting from 1. If you want the correct value from
coordinates.csv in ITK-Snap, add 1 to all dimensions.

USAGE

}
