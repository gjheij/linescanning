#!/usr/bin/env bash

#---------------------------------------------------------------------------------------------------------
# check if there's is a setup file containing the major paths and source it if it exists
call_loadsetup
source call_bashhelper

#---------------------------------------------------------------------------------------------------------
# Create help text
function Usage {
    cat <<USAGE

---------------------------------------------------------------------------------------------------
call_freesurfer

wrapper for surface parcellation with FreeSurfer. Called in spinoza_freesurfer. You can also run
this script after editing your volumes/surfaces. Read below what the possible options and defaults
are. The idea is to let fMRIprep run FreeSurfer 6.0.0 first, and then re-run FreeSurfer 7.1.0 with
this script to include a proper T2-based pial surface reconstruction (FS v6.0.0 is not well suited 
for this task). For this, FreeSurfer needs 'autodet.gw.stats.?h.dat'-files, which are created in 
step 20: 'Automatic Topology Fixer', right before -autorecon3. So in order to include T2 here we 
need to run autorecon2 and 3.

Usage:
  call_freesurfer -s <subj_ID> -t <t1 input> -p <t2 input> -r <recon stage (all | 1 | 2 | 3)>
                  -e <edit type> -o <other editing options> [other options]
Args:
  -s <subj ID>        subject ID as per output of FreeSurfer (e.g., 'sub-001')
  -t <t1 input>       T1-weighted image (not necessary if you're running debugging mode)
  -p <t2 input>       T2-weighted image (not necessary, but recommended for better pial-surface
                      segmentation
  -r <recon stage>    Which stage of recon-all should be run; combinations are possible!
                      Possible options are:
                        'all' = all stages (Perform all reconstruction steps, including
                                subcortical segmentation)
                        '1'   = autorecon1 (Motion correction through skull strip)
                        '2'   = autorecon2 (Subcortical segmentation through make final
                                surfaces)
                        '3'   = autorecon3 (Cortical parcellation)
                        '12'  = autorecon1 and autorecon2 (do your edits after this step)
                        '23'  = autorecon2 and autorecon3 (perform any edits and re-run with
                                '-e flag')
  -e <edit type>      What type of edit did you perform after autorecon2?
                      Possible options are:
                        'cp'  = you made normalization edits  > runs -autorecon2-cp
                        'wm'  = you made white matter edits   > runs -autorecon2-wm
                        'pial'= you made pial edits           > runs -autorecon-pial
                        'aseg'= edits to aseg.presurf.mgz     > runs -autorecon2-noaseg
  -j <cpus>           number of cores to use (default is 1)
  -o <other editing>  Here you can specify the gcut-option to remove latched on pial surface
  -x <expert opts>    expert option file that maps to '-expert'. 
  -q <queue>          submit jobs to a specific queue. Defaults to SGE_QUEUE_LONG in spinoza_setup
  --freeview          Open FreeView automatically (default is NO!)
  --force_exec        Force execution even though directory exists already
  --sge               Submit the script to a cluster using a template script
  --local             Force local processing even though cluster is available
  --no_t2             Do not reuse T2 with autorecon3. Must be used in concert with '-e' and
                      '-r'. By default, we'll re-use the T2 if present. Same flag should be 
                      used for not re-using FLAIR images
  --no_highres        Turn of highres mode by setting '-highres' flag empty
  --xopts-use         maps to '-xopts-use' for existing expert option file; use existing file
  --xopts-clean       maps to '-xopts-clean' for existing expert option file; delete existing 
                      file
  --xopts-overwrite   maps to '-xopts-overwrite' for existing expert option file; use new file

Instructions for editing (from Andrew Jahn's YouTube series):
  - Control points (intensity normalization errors):
    White matter is incorrectly labeled as gray matter, which happens mostly in the ventral-
    temporal lobes and the orbito-frontal cortex. You can fix this with 'control points', which
    boost the intensity surrounding the control point

    1.) Open freeview with 'call_freeview <subj ID> surf 0'
    2.) Find slices where the problems begins and starts (easiest in axial view)
    3.) To add control points, click 'File'>'New point set'>name it 'control.dat'>select 'brain-
        mask.mgz' as tempalte
    4.) Left-click voxels that are white matter but not included in the WM-boundary. Space out 
        control points by a few mm
    5.) When you're done, click on 'File'>'Save Point Set as'>'control.dat' in the 'tmp'-folder
    6.) Re-run with call_freesurfer -s sub-001 -r 23 -e cp

  - Skullstripping: the GCUT-option
    When the skull has been mostly removed, but excessive dura remain, you can use the GCUT-option.

    1.) Make a back-up of the directory
    2.) Run call_freesurfer -s <subj ID> -o gcut
    3.) This outputs a file called brainmask.gcut.mgz
    4.) If this has fixed the problem, run call_freesurfer -s <subj ID> -r 23 (leave '-e' empty so 
        we know you did gcut)

  - Pial edits:
    If the above strategy was not successful, you can try more aggressive skullstripping, but this 
    usually does more harm than good. In that case, pial-edits are recommended.

    1.) Open freeview with 'call_freeview <subj ID> surf 0'
    2.) Make sure 'brainmask.mgz' is highlighted, and press 'recon-edit' icon (head with 'R' and 
        pencil)
    3.) To remove voxels, pressing 'shift'+left mouse
    4.) Find slices where the problems begins and starts (easiest in axial view). Be conservative 
        though!
    5.) When you're done, press 'File'>'Save Volume'
    6.) Re-run with call_freesurfer -s sub-001 -r 23 -e pial

Example (TL;DR):
  Regular recon-all:      call_freesurfer -s <subj ID> -t <T1 image> -p <T2 image> -r all
  Run gcut:               call_freesurfer -s <subj ID> -o gcut
  After gcut:             call_freesurfer -s <subj ID> -r 23
  After control points:   call_freesurfer -s <subj ID> -r 23 -e cp
  After call_gdhinject:   call_freesurfer -s <subj ID> -r 23 -e wm
  After pial edits:       call_freesurfer -s <subj ID> -r 23 -e pial
  Include T2 after FS v6: call_freesurfer -s <subj ID> -r 23 -e wm -p <T2 image>

Notes:
  When an expert options is passed, it will be copied to scripts/expert-options. Future calls to 
  recon-all, the user MUST explicitly specify how to treat this file. Options are (1) use the file 
  ('--xopts-use'), or (2) delete it ('--xopts-clean'). If this file exsts and the user specifies 
  another expert options file, then the user must also specify '--xopts-overwrite'.

---------------------------------------------------------------------------------------------------

USAGE
}

#-----------------------------------------------------------------------------
# Deal with arguments
FREEVIEW=0
FORCE_EXEC=0
SGE=""
highres_flag="-hires"
XOPTS_=""
EXPERT_FILE=""
reuse_t2=1
allowed_edits=("cp" "wm" "pial" "aseg")
n_cpus=1
while getopts :-:hs:t:p:r:e:o:f:c:x:q:j: arg
do
  case ${arg} in
    -)
      case "${OPTARG}" in     
        freeview)
          FREEVIEW=1
          ;;            
        force_exec)
          FORCE_EXEC=1
          ;;          
        sge)
          SGE="SGE"
          ;;        
        local)
          SGE="LOCAL"
          ;;   
        no_highres)
          highres_flag=""
          ;; 
        no_t2)
          reuse_t2=0
          ;;            
        xopts-use)
          XOPTS_="-xopts-use"
          ;;             
        xopts-clean)
          XOPTS_="-xopts-clean"
          ;;               
        xopts-overwrite)
          XOPTS_="-xopts-overwrite"
          ;;              
        *)
          if [ "$OPTERR" = 1 ] && [ "${optspec:0:1}" != ":" ]; then
            Usage >&2
            echo "Unknown option --${OPTARG}"
            exit 1
          fi
          ;;
      esac;;    
    s)  subj_ID=${OPTARG}
          ;;
    t)  T1=${OPTARG}
          ;;
    p)  T2=${OPTARG}
          ;;
    r)  stage=${OPTARG}
          ;;
    e)  edit=${OPTARG}
          ;;
    o)  option=${OPTARG}
          ;;
    x)  EXPERT_FILE=${OPTARG}
          ;;    
    q)  SGE_QUEUE=${OPTARG}
          ;;  
    j)  n_cpus=${OPTARG}
          ;;                                      
  esac
done

if [[ $# -lt 2 ]] ; then
  Usage >&2
  exit 1
fi

if [[ -z ${SUBJECTS_DIR} ]]; then
  echo "SUBJECTS_DIR is not set"
  exit 1
fi

if [[ -z ${subj_ID} ]]; then
  echo "Whatever you want to do, I'll always need a subject ID"
  exit 1
fi

if [[ -z ${SGE} ]]; then
  # read from spinoza_setup
  if [[ ${PLACE} == "SGE" ]]; then
    SGE="SGE"
  else
    SGE="LOCAL"
  fi
fi

# check if we got expert file
if [[ ! -z ${EXPERT_FILE} ]]; then
  if [[ ! -f ${EXPERT_FILE} ]]; then
    echo "ERROR in `basename ${0}`: specified expert file \"${EXPERT_FILE}\" does not exist"
    exit 1
  fi
  expert_flag="-expert ${EXPERT_FILE}"
  echo "Expert options: \"${EXPERT_FILE}\""

  # check if there's an expert-options file already and whether the user has specified a protocol
  if [[ -f ${SUBJECTS_DIR}/${subj_ID}/scripts/expert-options ]]; then
    if [[ -z ${XOPTS_} ]]; then
      echo "ERROR in `basename ${0}`: an expert-options file was specified, but one already exists."
      echo "Please specify the protocol to deal with this with one of the following flags:"
      echo "  1) --xopts-use;       use the existing file"
      echo "  2) --xopts-clean;     delete the existing file"
      echo "  3) --xopts-overwrite; use a new file"
      exit 1
    fi
  fi
else
  XOPTS_=""
  expert_flag=""
fi

#-----------------------------------------------------------------------------
# Create function that submits or runs stuff locally
CMD(){

  # $1 = subject ID (subj_ID)
  # $2 = stage nr
  # $3 = stage flag (stage)
  # $4 = T1_flag
  # $5 = T2_flag

  # check if function exists, will throw an error if it doesn't exist
  fn_exists freesurfer
  echo "Using FreeSurfer from: `which freesurfer`"

  if [[ ${SGE} == "SGE" ]]; then
    echo "Submitting job to cluster with ${n_cpus} core(s)"
    parallel_flag="-parallel"
    mp_flag="-openmp ${n_cpus}"
    submit=1
  else
    parallel_flag=""
    mp_flag="-nthreads ${n_cpus}"
    submit=0
  fi

  # delete previously existing file
  fs_script=${PATH_HOME}/freesurfer/${PROJECT}/${1}_${2}.sh
  echo $fs_script
  if [[ -f ${fs_script} ]]; then
    rm -r ${fs_script}
  fi

  # bash will complain if you want to create a file but the directory doesn't exist
  if [[ ! -d $(dirname ${fs_script}) ]]; then
    mkdir -p $(dirname ${fs_script})
  fi

  # remove old log file
  if [ -f $(dirname ${fs_script})/$(basename ${fs_script} .sh).log ]; then
    rm $(dirname ${fs_script})/$(basename ${fs_script} .sh).log
  fi 

  # If you have ran FreeSurfer in fMRIprep, fsaverage will miss a few labels that
  # FreeSurfer v7 has.
  if [[ ! -z ${SGE_QUEUE} ]]; then
    QUEUE=${SGE_QUEUE}
  else
    QUEUE=${SGE_QUEUE_LONG}
  fi    
  
  # echo "${SUBJECTS_DIR}"
  (
  echo "#!/bin/bash"
  echo "#$ -S /bin/bash"
  echo "#$ -N $(basename ${fs_script} .sh)"
  echo "#$ -wd ${SUBJECTS_DIR}"
  echo "#$ -o $(dirname ${fs_script})/$(basename ${fs_script} .sh).log"
  echo "#$ -j Y"
  echo "#$ -q ${QUEUE}"
  echo "#$ -V"
  echo ""
  echo "export SUBJECTS_DIR=${SUBJECTS_DIR}"
  echo "recon-all -subjid ${1} ${4} ${highres_flag} ${parallel_flag} ${mp_flag} ${3} ${5} ${expert_flag} ${XOPTS_}"
  ) > ${fs_script}
  
  if [[ ${submit} -eq 1 ]]; then
    qsub -pe smp ${n_cpus} ${fs_script}
    echo "Now wait until the program has finished and do some editing in FreeView if required."
    echo "Waiting to qstat.."
    sleep 5
    qstat
  else
    echo "Running FreeSurfer locally"
    bash ${fs_script}
    echo "Now do some editing in FreeView if required."
  fi

}

CHECK_INPUTS(){

  T1_flag=""
  T2_flag=""
  if [ -z ${T1} ]; then
    if [[ ${1} == "all" || ${1} == *"1"* ]]; then
      echo "Could not find T1-weighted image"
      exit 1
    fi
  else
    if [[ ${1} == "all" || ${1} == *"1"* ]]; then
      T1=`fetch_filepath ${T1}`
      T1_flag="-i ${T1}"
    fi
  fi

  if [[ ! -z ${T2} ]]; then
    # also got a T2 weighted image
    T2=`fetch_filepath ${T2}`

    # check if input if FLAIR or T2
    if [[ ${T2} == *"T2w.nii.gz"* ]]; then
      if [[ ${1} == "all" ]]; then
        T2_flag="-T2 ${T2} -T2pial"
      else
        if [[ ${reuse_t2} -eq 1 ]]; then
          T2_flag="-T2pial"
        else
          T2_flag=""
        fi
      fi
    elif [[ ${T2} == *"FLAIR.nii.gz"* ]]; then
      if [[ ${1} == "all" ]]; then
        T2_flag="-FLAIR ${T2} -FLAIRpial"
      else
        if [[ ${reuse_t2} -eq 1 ]]; then
          T2_flag="-FLAIRpial"
        else
          T2_flag=""
        fi
      fi
    else
      echo "ERROR in `basename ${0}`: file must end with T2w.nii.gz or FLAIR.nii.gz"
      exit 1
    fi
  else
    # for stage != 'all', check if there's a T2.mgz file in the mri folder if no T2 image was specified
    if [[ ${1} != "all" || ${1} != *"1"* ]]; then
      if [[ ${reuse_t2} -eq 1 ]]; then
        if [[ -f ${SUBJECTS_DIR}/${subj_ID}/mri/T2.mgz ]]; then
          T2_flag="-T2pial"
        elif [[ -f ${SUBJECTS_DIR}/${subj_ID}/mri/FLAIR.mgz ]]; then
          T2_flag="-FLAIRpial"
        fi
      fi
    else
      T2_flag=""
    fi
  fi

}

ISRUNNING(){
  is_running=${SUBJECTS_DIR}/${subj_ID}/scripts/IsRunning.lh+rh
  if [[ -f ${is_running} ]]; then
    rm -r ${is_running}
  fi
}

CHECK_EXECUTION(){

  # execute either when there's no directory, or when there's no files in /surf, or force_exec=1
  execute=0

  if [[ -d ${SUBJECTS_DIR}/${subj_ID} ]]; then
    if [[ ! -d ${SUBJECTS_DIR}/${subj_ID}/surf ]]; then
      reason="directory \"${SUBJECTS_DIR}/${subj_ID}\" is empty"
      execute=1
    else
      nr_files=`ls -l ${SUBJECTS_DIR}/${subj_ID}/surf | grep "total" | cut -d' ' -f2`
      if [ ${nr_files} -eq 0 ]; then
        reason="directory \"${SUBJECTS_DIR}/${subj_ID}/surf\" is empty"
        execute=1
      fi
    fi
    
    if [ ${FORCE_EXEC} -eq 1 ]; then
      reason="--force_exec was specified"
      execute=1
    fi
  else
    reason="new FreeSurfer subject"
    execute=1
  fi
  
}

#-----------------------------------------------------------------------------
# Run it

if [[ ! -d ${SUBJECTS_DIR} ]]; then
  mkdir -p ${SUBJECTS_DIR}
fi

# start with the simplest option: check if there's gcut
if [[ ! -z ${option} ]]; then

  if [ ! -d ${SUBJECTS_DIR}/${subj_ID} ]; then
    echo "You're trying to run gcut (i presume) before running recon-all..?"
    exit 1
  else
    if [[ ${option} != "gcut" ]]; then
      echo "Have not implemented ${option}, yet. Please specify \"gcut\" if this is what you wanted"
      exit 1
    fi
  fi

  if [ ! -d ${SUBJECTS_DIR}/${subj_ID}_backup ]; then
    echo "Backing up FS-directory"
    cp -r ${SUBJECTS_DIR}/${subj_ID} ${SUBJECTS_DIR}/${subj_ID}_backup
  fi

  if [[ -z ${edit} ]]; then
    echo "Running gcut .."
    recon-all -skullstrip -clean-bm -gcut -s ${subj_ID}
  else
    echo "You specifed \"-e\" for the gcut option.. This is not necessary"
    exit 1
  fi

  if [[ ${FREEVIEW} -eq 1 ]]; then

    # check if we have a function called call_freeview
    call_checkfunction call_freeview

    if [[ $? == 0 ]]; then
      echo "Opening Freeview .."
      call_freeview ${subj_ID}
    else
      echo "you do not have the call_freeview script where it's supposed to be"
      echo "place it in \"${DIR_SCRIPTS}/bin\""
      exit 1
    fi

    echo "Run recon-all again or not [n] = no, [y] = yes"
    while : ; do
      read -n 1 k <&1
      if [[ ${k} = n ]]; then
        echo "Quitting from the program"
        break
      elif [[ ${k} = y ]]; then
        echo "Running recon stage 2+3 with gcut option"
        CMD "${subj_ID}" "23" "-autorecon2 -autorecon3"

      else
        echo "Unknown option. Something weird happened.."
        exit 1
      fi
    done

  fi

# do all other things when -o is not specified
else

  if [[ -z ${stage} ]]; then
    echo "What stage do you want to run? Please specify the \"-r\"-flag"
    exit 1
  fi

  if [[ ${stage} == "all" ]]; then

    # check for T1 and T2
    CHECK_INPUTS ${stage}

    if [[ ! -z ${edit} ]]; then
      echo "You want to run all stages of recon-all but specified the \"edit\" flag. This is not necessary"
    fi

    # check execution; sets 'execution' and 'reason' variables
    CHECK_EXECUTION

    if [[ ${execute} -eq 1 ]]; then
      echo "Reason to execute: ${reason}"
      CMD "${subj_ID}" "${stage}" "-all" "${T1_flag}" "${T2_flag}"
    else
      echo "This step is already complete; use '--force_exec' to force execution"    
    fi

  elif [[ ${stage} == "12" ]]; then

    # check for T1 and T2
    CHECK_INPUTS ${stage}

    # remove running job
    ISRUNNING

    if [[ ! -z ${edit} ]]; then
      echo "You want to run all stages of recon-all but specified the \"edit\" flag. This is not necessary"
    fi

    CMD "${subj_ID}" "${stage}" "-autorecon1 -autorecon2" "${T1_flag}" "${T2_flag}"

  elif [ ${stage} == "23" ]; then

    # check for T1 and T2 flags; the actual inputs are not required, but the flags must be present 
    CHECK_INPUTS ${stage}

    # remove running job
    ISRUNNING

    if [[ ! -z ${edit} ]]; then

      # check if specified edit stage is an allowed option
      if [[ ! " ${allowed_edits[*]} " =~ " ${edit} " ]]; then
        Usage >&2
        echo
        echo "ERROR: To run this mode, you need to specify \"cp\", \"wm\", \"pial\", or \"aseg\" to let me know your type of edit.."
        exit 1
      fi

      if [[ ${edit} == "pial" ]]; then
        edit_flag="-autorecon-pial -autorecon3"
      elif [[ ${edit} == "aseg" ]]; then
        edit_flag="-autorecon2-noaseg -autorecon3"
      else
        edit_flag="-autorecon2-${edit} -autorecon3"
      fi
    else
      edit_flag="-autorecon2 -autorecon3"
    fi

    CMD "${subj_ID}" "${stage}" "${edit_flag}" "${T1_flag}" "${T2_flag}"

  elif [[ ${stage} == "1" ]]; then

    # check for T1 and T2
    CHECK_INPUTS ${stage}

    # check execution; sets 'execution' and 'reason' variables
    CHECK_EXECUTION

    if [[ ${execute} -eq 1 ]]; then
      echo "Reason to execute: ${reason}"
      CMD "${subj_ID}" "${stage}" "-autorecon1" "${T1_flag}" "${T2_flag}"
    else
      echo "This step is already complete; use '--force_exec' to force execution"
    fi

  elif [[ ${stage} == "2" ]]; then

    # remove running job
    ISRUNNING

    CMD "${subj_ID}" "${stage}" "-autorecon2"

  elif [[ ${stage} == "3" ]]; then

      # remove running job
    ISRUNNING

    # check for T1 and T2
    CHECK_INPUTS ${stage}

    CMD "${subj_ID}" "${stage}" "-autorecon3" "${T1_flag}" "${T2_flag}"

  fi

fi
