#!/usr/bin/env bash

# source helper functions
source call_bashhelper

#---------------------------------------------------------------------------------------------------------
# Create help text
function Usage {
    cat <<USAGE

---------------------------------------------------------------------------------------------------
call_parrec2nii

Wrapper for the parrec2nii to make life a little easier. In theory, it'll only require and input di-
rectory containing the files to be converted. If no output directory is specified, the script will
create a directory called INPUT/nifti and store the output there. Because parrec2nii does not out-
put a json side-car file by default, we'll attempt to create one based on the information found in 
the par-file; some information (e.g., RepetitionTime) could be missing.

Parameters
----------
  -i <input>          PAR-file or folder containing PAR-files to be processed. Always needed!
  -o <output folder>  output folder. If empty, it will use <input folder>/nifti
  -c <compress>       create nii's ("n") or nii.gz's (default)

Example
----------
  call_parrec2nii -i /path/to/PARRECs       # call with folder
  call_parrec2nii -i /path/to/file.par      # call with file
  call_parrec2nii -i /path/to/PARRECs -c n  # don't compress

---------------------------------------------------------------------------------------------------

USAGE
    exit 1
}

# Allocate input arguments to variables
#
while getopts i:o:c:v: argument
do
  case ${argument} in
    i)  pathInput=${OPTARG}
          ;;
    o)  pathOutput=${OPTARG}
          ;;
    c)  compress=${OPTARG}
          ;;
  esac
done

if [[ $# -lt 1 ]] ; then
  Usage >&2
  exit 1
fi

#-----------------------------------------------------------------------------
# Get bash helper functions
source call_bashhelper

#-----------------------------------------------------------------------------
# Check if we have parrec2nii installed

fn_exists()
{
  FN=`type -t $1`

  if [[ -z ${FN} ]]; then
    echo "Didn't find parrec2nii, please install nibabel"
    exit 1
  fi
}

cmd="parrec2nii"
fn_exists ${cmd}

#-----------------------------------------------------------------------------
# Set default inputs/outputs
if [[ -z ${pathInput} ]]; then
  echo "ALWAYS NEED AT LEAST AN INPUT FOLDER/FILE"
  Usage >&2
  exit 1
fi

pathInput=`fetch_filepath ${pathInput}`
if [[ -z ${pathOutput} ]]; then
  if [ -f ${pathInput} ]; then
    pathOutput=$(dirname ${pathInput})/nifti
  else
    pathOutput=${pathInput}/nifti
  fi
fi

# -z : gz compress images (y/o/i/n/3, default n) [y=pigz, o=optimal pigz, i=internal:zlib, n=no, 3=no,3D]
if [[ -z ${compress} ]]; then
  NIIGZ="o"
  COMPR="-c"
else
  if [[ ${compress} == "n" ]]; then
    COMPR=""
  fi
fi

#-----------------------------------------------------------------------------
# Run it

if [[ ! -d ${pathOutput} ]]; then
  mkdir -p ${pathOutput}
fi

# check if input is directory or loose file
if [[ -d ${pathInput} ]]; then
  ff=`find ${pathInput} -type f -iname "*.par" 2>/dev/null`
else
  ff=${pathInput}
fi

IFS=$'\n' par_files=($(sort <<<"${ff[*]}"))
unset IFS   
for par in ${par_files[@]}; do

  orig_out=${pathOutput}/$(basename ${par} .par).nii.gz
  if [ ! -f ${orig_out} ]; then
    ${cmd} --scaling fp --verbose ${COMPR} -o ${pathOutput} ${par}
    if [[ $? -ne 0 ]]; then
      echo "\"${cmd}\" exited with non-zero status"
      exit 1
    fi
  else
    echo "Converted file exists, continuing to BIDS/json stuff"
  fi

  # rename according to Protocol Name & Patient Name | read_par comes from call_bashhelper
  pat=`read_par ${par} "Patient name"`
  prot=`read_par ${par} "Protocol name"`

  # check if volumes are doubled (in case ofll phase data)
  phase=0
  dyns=`read_par ${par} "number of dynamics"`
  vols=`fslval ${orig_out} dim4 | xargs`

  bids_out=${pathOutput}/${pat}_${prot}
  if [ ${vols} != ${dyns} ]; then

    if [[ ! -f ${bids_out}.nii.gz && ! -f ${bids_out}_ph.nii.gz ]]; then
      echo "Output has ${vols} volumes, but PAR-file says ${dyns}; assuming interleaved phase data"

      PYTHON_CODE=$(cat <<END
import nibabel as nb;
import os;
import numpy as np;
opj = os.path.join;
ff = '${orig_out}';
img = nb.load(ff);
data = img.get_fdata();
mag = data[...,::2];
pha = data[...,1::2];
out = '${bids_out}';
nb.Nifti1Image(mag, affine=img.affine, header=img.header).to_filename(out+'.nii.gz');
nb.Nifti1Image(pha, affine=img.affine, header=img.header).to_filename(out+'_ph.nii.gz');
END
)
      echo "Extracting and saving interleaved magnitude/phase data"
      python -c "$PYTHON_CODE"
    fi
  else
    if [[ ! -f ${bids_out}.nii.gz ]]; then
      mv ${orig_out} ${bids_out}.nii.gz 2>/dev/null
    fi
  fi

  # define json file
  json_f=${bids_out}.json
  echo "Writing ${json_f}"
  
  # function is from call_bashhelper
  pars_for_json ${par} ${json_f}
  
  # check corresponding EPI file
  if [[ ${bids_out} == *"_bold"* ]]; then
    epi=`echo $(basename ${bids_out} | sed "s|_bold|_epi|g")`

    if [ -f $(dirname ${bids_out})/${epi}.nii.gz ]; then
      base_path=""
      if [[ ${pat} == *"ses"* ]]; then
        ses_nr=$(echo ${pat} | cut -d"_" -f2)
        base_path+="${ses_nr}"
      fi

      # try to read TR from EPI json file
      epi_json=$(dirname ${bids_out})/${epi}.json
      if [ -f ${epi_json} ]; then
        declare -a find_keys=("RepetitionTime" "EchoTime")
        for key in ${find_keys[@]}; do
          val=`read_json ${epi_json} ${key}`
          if [[ ! -z ${val} ]]; then
            echo "Found ${key}: ${val}"
            call_json ${json_f} ${key} ${val}
          fi
        done
      fi

      echo "Adding basic information to $(basename ${epi_json})"

      # add the regular parameters to EPI json
      pars_for_json --merge ${par} ${epi_json}

      # add IntendedFor field
      call_json ${epi_json} IntendedFor ${base_path}/func/$(basename ${bids_out}).nii.gz
    fi
  fi

done