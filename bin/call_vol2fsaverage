#!/usr/bin/env bash

#---------------------------------------------------------------------------------------------------------
# Create help text
function Usage {
    cat <<USAGE

---------------------------------------------------------------------------------------------------
call_vol2fsaverage

This script projects a volume in subject space to the surface from FSAverage. Assumes that the vo-
lume is in FS-space (can be achieved with spinoza_line2surface). It first projects the volume to
the surface of the subject with mri_vol2surf, and then to the surface of FSAverage with mri_surf2-
surf. It will do the projection for both hemispheres automatically. 

If you have a file that is not in the volumetric space of FSNative, you can supply transformation
files to do this before sampling it to the surface. Some flags from call_antsapplytransforms are
therefore inherited, such as '-i' (for inverting matrices) and the interpolation methods (default
is 'Linear' [--lin]). Use '--gen' for masks and 'mul' for files lookup-table files (label files)

Args:
  <-r file>   registration file; sometimes useful if you're warping partial FOVs and want to use
              an identity matrix for instance.
  <-o out>    output directory
  <-p prefix> use custom prefix rather than <subject>
  <-t trafo>  (list of) transformation file(s) to apply to get the data in FSNative space before
              sampling them to the surface. Should a format that is compatible with call_ants-
              applytransforms (comma-separated in order of application)
  -i <invert> invert given warp files (0=no|1=yes; leave empty for 'no'). If you have multiple
              warp files, specify a space-separated list between quotes as inversion tag; if not
              everything will be set to 'do not invert'  
  --<interp>    interpolation type: 'lin' (linear), 'nn' (NearestNeighbor), mul (MultiLabel), gau 
                (Gaussian), bspl<order>, cws (CosineWindowedSinc), wws (WelchWindowedSinc), hws 
                (HammingWindowedSinc), lws (LanczosWindowedSinc), gen (GenericLabel); default = 'nn'
                For instance, to use 'Linear' interpolation, use '--lin', for 'GenericLabel', use
                '--gen'                                                  
  <--tr>      set repetition time in .gii-files
  <subject>   subject ID as used in the FreeSurfer directory
  <in_file>   path to the input file that needs to be projected to the surface
  <suffix>    suffix for the output. The output file will be an .gii file in both the subject-
              specific folder (mri_vol2surf) and fsaverage/volumes. <subject>_hemi-<L|R>_space-
              <fsnative|fsaverage>_<suffix>.gii is default

Usage:
  call_vol2fsaverage [options] <subject> <in_file> <out_name>

Example:
  call_vol2fsaverage sub-001 t1map.nii.gz T1map
  call_vol2fsaverage -r ident.dat sub-001 bold.nii.gz bold.func
  call_vol2fsaverage -o /some/directory -r ident.dat sub-001 bold.nii.gz bold.func
  call_vol2fsaverage -p sub-999_ses-1_task-pRF -r ident.dat sub-001 bold.nii.gz run-1_bold.func
  call_vol2fsaverage -t from-T1w_to-bold.mat -i 0 sub-001 bold.nii.gz bold.func
---------------------------------------------------------------------------------------------------

USAGE
    exit 1
}

if [[ $# -lt 3 ]] ; then
  Usage >&2
  exit 1
fi

set_tr=0
INT="Linear"
VERB=0
# Check for subject & session flags
while getopts :-:r:o:p:t:i: argument
do
  case ${argument} in
    -)
      case "${OPTARG}" in
        tr)
          set_tr=1
          ;;
        lin)
          INT="Linear"
          ;;
        nn)
          INT="NearestNeighbor"
          ;;
        mul)
          INT="MultiLabel"
          ;;         
        gau)
          INT="Gaussian"
          ;;               
        bspl*)
          INT="BSpline[$(basename ${OPTARG} | cut -c 5)]"
          ;;       
        cws)
          INT="CosineWindowedSinc"
          ;;
        wws)
          INT="WelchWindowedSinc"
          ;;
        hws)
          INT="HammingWindowedSinc"
          ;;
        lws)
          INT="LanczosWindowedSinc"
          ;;    
        gen)
          INT="GenericLabel"
          ;;
        mul)
          INT="MultiLabel"
          ;; 
        verbose)
          VERBOSE="--verbose"
          VERB=1
          ;;                  
        *)
          if [ "$OPTERR" = 1 ] && [ "${optspec:0:1}" != ":" ]; then
            echo "Unknown option --${OPTARG}, did you mean \"--lines\"?"
            exit 1
          fi
          ;;  
      esac;;    
    r)  reg_file=${OPTARG}
          ;;
    o)  out_dir=${OPTARG}
          ;;
    p)  prefix=${OPTARG}
          ;;
    t)  trafos=${OPTARG}
          ;;        
    i)  invert="-i ${OPTARG}"
          ;;            
  esac
done

SUBJECT=${@:$OPTIND:1}
INPUT=${@:$OPTIND+1:1}
SUFFIX=${@:$OPTIND+2:1}

if [[ -z ${reg_file} ]]; then
  REG="--regheader ${SUBJECT}"
else
  REG="--reg ${reg_file}"
fi

if [[ -z ${out_dir} ]]; then
  fsnative_dir=${SUBJECTS_DIR}/${SUBJECT}/mri
  fsaverage_dir=${SUBJECTS_DIR}/fsaverage/volumes
else
  fsnative_dir=${out_dir}
  fsaverage_dir=${out_dir}
fi

if [[ -z ${prefix} ]]; then
  PREF=${SUBJECT}
else
  PREF=${prefix}
fi

if [[ ${set_tr} -eq 1 ]]; then
  TR_float_sec=`fslval ${INPUT} pixdim4`

  # convert to integer in milliseconds to be consistent with fMRIprep
  TR_int_ms="$(printf '%d' `echo "${TR_float_sec} * 1000" | bc` 2>/dev/null)"
  echo "Setting TR to ${TR_int_ms}"
else
  TR_int_ms=""
fi

#-----------------------------------------------------------------------------
# check if we got transformation files to apply to INPUT
if [[ ! -z ${trafos} ]]; then
  fixed=${SUBJECTS_DIR}/${SUBJECT}/mri/orig.mgz
  moving=${INPUT}
  out=${fsnative_dir}/${PREF}_space-fsnative_${SUFFIX}.nii.gz

  cmd="call_antsapplytransforms ${VERBOSE} ${invert} ${fixed} ${moving} ${out} ${trafos}"
  if [[ ${VERB} -eq 1 ]]; then
    echo ${cmd}
  fi

  # run
  ${cmd}

  if [[ $? -ne 0 ]]; then
    echo "ERROR in `basename ${0}`: call_antsapplytransforms exited with non-zero status"
    exit 1
  fi
  
  # set output from call_antsapplytransforms to new input for surface sampling
  INPUT=${out}

  if [ ${VERB} -eq 1 ]; then
    echo
  fi 
fi

#-----------------------------------------------------------------------------
# Run it
for ii in "lh" "rh"; do

  if [[ ${ii} == "lh" ]]; then
    hemi="hemi-L"
  elif [[ ${ii} == "rh" ]]; then
    hemi="hemi-R"
  fi

  # project volume to subject-specific space
  fsnative=${fsnative_dir}/${PREF}_space-fsnative_${hemi}_${SUFFIX}.gii
  mri_vol2surf --src ${INPUT} --out ${fsnative} ${REG} --hemi ${ii} --projfrac 0.5

  if [[ $? -ne 0 ]]; then
    echo "ERROR in `basename ${0}`: mri_vol2surf exited with non-zero status"
    exit 1
  fi

  # project the output to fsaverage
  fsaverage=${fsaverage_dir}/${PREF}_space-fsaverage_${hemi}_${SUFFIX}.gii
  if [[ ! -d ${fsaverage_dir} ]]; then
    mkdir -p ${fsaverage_dir}
  fi

  mri_surf2surf \
    --srcsubject ${SUBJECT} \
    --trgsubject fsaverage \
    --hemi ${ii} \
    --sval ${fsnative} \
    --tval ${fsaverage}

  if [[ $? -ne 0 ]]; then
    echo "ERROR in `basename ${0}`: mri_surf2surf exited with non-zero status"
    exit 1
  fi

done

echo "Stacking gifti's into numpy-array"
# stacking giftis into numpy array so we can load them in with Pycortex
for space in 'fsnative' 'fsaverage'; do

  if [ ${space} == "fsaverage" ]; then
    output_path=${fsaverage_dir}
  else
    output_path=${fsnative_dir}
  fi

  lh=${output_path}/${PREF}_space-${space}_hemi-L_${SUFFIX}.gii
  rh=${output_path}/${PREF}_space-${space}_hemi-R_${SUFFIX}.gii
  both_hemis=${output_path}/${PREF}_space-${space}_hemi-LR_${SUFFIX}.npy
  call_stackgifti ${lh} ${rh} ${both_hemis}

  if [[ $? -ne 0 ]]; then
    echo "ERROR in `basename ${0}`: call_stackgiftis exited with non-zero status"
    exit 1
  fi

  if [ ${VERB} -eq 1 ]; then
    echo "Wrote ${both_hemis}"
  fi

  # add TR to metadata of gifti
  if [[ ${set_tr} -eq 1 ]]; then
    if [[ ! -z ${TR_int_ms} ]]; then
      call_giftimeta ${lh} "${TR_int_ms}"
      call_giftimeta ${rh} "${TR_int_ms}"

      if [[ $? -ne 0 ]]; then
        echo "ERROR in `basename ${0}`: call_giftimeta exited with non-zero status"
        exit 1
      fi
    fi
  fi

done

