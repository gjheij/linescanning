#!/usr/bin/env bash

function Usage {
    cat <<USAGE

---------------------------------------------------------------------------------------------------
call_antsapplytransforms

This script is a wrapper that makes the call to antsApplyTransforms a little easier. You'll only
need to specify the <fixed>/<moving> image, and output name, whether or not to invert the specified
warp files (0=no; 1=yes), and the list of the warp files in order of application! It is important
that the warp files are specified in the last argument, as that's what the script will create a list
of warps from.

Args:
  -v|--verbose  Turn on verbose
  --<interp>    interpolation type: 'lin' (linear), 'nn' (NearestNeighbor), mul (MultiLabel), gau 
                (Gaussian), bspl<order>, cws (CosineWindowedSinc), wws (WelchWindowedSinc), hws 
                (HammingWindowedSinc), lws (LanczosWindowedSinc), gen (GenericLabel); default = 'nn'
                For instance, to use 'Linear' interpolation, use '--lin', for 'GenericLabel', use
                '--gen'
  -i <invert>   invert given warp files (0=no|1=yes; leave empty for 'no'). If you have multiple
                warp files, specify a comma-separated list between quotes as inversion tag (e.g., 
                '-i 0,1'); if not everything will be set to 'do not invert'
  <ref>         space to warp file to
  <moving>      file to warp
  <output>      moving-in-ref output name
  <warp files>  all warp files in order of application; specify a comma-separated list if multiple
                files need to be considerd (e.g., 'file1.mat,file2.mat')

Usage:
  call_antsapplytransforms -i <invert 0=no|1=yes> --<interp> <ref> <moving> <output> <warp files>

Example:
  call_antsapplytransforms ref.nii.gz mov.nii.gz out.nii.gz genaff.mat
  call_antsapplytransforms -i 1 --lin ref.nii.gz mov.nii.gz out.nii.gz genaff.mat
  call_antsapplytransforms -i 0,1 ref.nii.gz mov.nii.gz out.nii.gz genaff1.mat,genaff2.mat

---------------------------------------------------------------------------------------------------

USAGE
    exit 1
}

source call_bashhelper

# Check for subject flag
INT="Linear"
VERB=0
while getopts :-:vi:t: argument
do
  case ${argument} in
    -)
      case "${OPTARG}" in
        lin)
          INT="Linear"
          ;;
        nn)
          INT="NearestNeighbor"
          ;;
        mul)
          INT="MultiLabel"
          ;;         
        gau)
          INT="Gaussian"
          ;;               
        bspl*)
          INT="BSpline[$(basename ${OPTARG} | cut -c 5)]"
          ;;       
        cws)
          INT="CosineWindowedSinc"
          ;;
        wws)
          INT="WelchWindowedSinc"
          ;;
        hws)
          INT="HammingWindowedSinc"
          ;;
        lws)
          INT="LanczosWindowedSinc"
          ;;    
        gen)
          INT="GenericLabel"
          ;;
        mul)
          INT="MultiLabel"
          ;;                  
        verbose)
          VERBOSE="--verbose 1"
          VERB=1
          ;;
        *)
          if [ "$OPTERR" = 1 ] && [ "${optspec:0:1}" != ":" ]; then
            echo "Unknown option --${OPTARG}"
            exit 1
          fi
          ;;
      esac;;        
    i)  invert=${OPTARG}
          ;;
    v)  VERBOSE="--verbose 1"
        VERB=1
          ;;          
  esac
done

if [[ $# -lt 4 ]] ; then
  Usage >&2
  exit 1
fi

REF=`fetch_filepath ${@:$OPTIND:1}`
MOV=`fetch_filepath ${@:$OPTIND+1:1}`
OUT=`fetch_filepath ${@:$OPTIND+2:1}`
TRAFOS=${@:$OPTIND+3:1}

# read transformations into array
IFS=', ' read -r -a WARP <<< "${TRAFOS}"
unset IFS

# match invert flags
if [[ ! -z ${invert} ]]; then
  IFS=', ' read -ra LIST <<< ${invert[@]}
  unset IFS
else
  LIST=()
  ct=0
  for i in ${WARP[@]}; do
    LIST+=(0)
  done
fi

ARRAY=()
if [[ ${WARP} == "identity" ]] || [[ ${WARP} == "ident" ]] || [[ ${WARP} == "identty" ]]; then
  call_createident -s "tmp" $(dirname ${OUT})/ident.mat
  INITIAL=$(echo "-t [$(dirname ${OUT})/ident.mat,0]")
  ARRAY+=("${INITIAL}")
else
  j=0
  for i in ${WARP[@]}; do
    INITIAL=$(echo "-t [${i},${LIST[${j}]}]")
    ARRAY+=("${INITIAL}")
    ((j++))
  done
fi

# check if we have mgz file
REF_ext=`fetch_extension ${REF}`
MOV_ext=`fetch_extension ${MOV}`

if [[ ${REF_ext} == "mgz" ]]; then
  call_mriconvert ${REF} && echo
  REF=$(dirname ${REF})/$(basename ${REF} .mgz).nii.gz
fi

if [[ ${MOV_ext} == "mgz" ]]; then
  call_mriconvert ${MOV} && echo
  MOV=$(dirname ${MOV})/$(basename ${MOV} .mgz).nii.gz
fi

if [[ ! -d $(dirname ${OUT}) ]]; then
  mkdir -p $(dirname ${OUT})
fi

cmd="antsApplyTransforms -d 3 --float 1 ${VERBOSE} -n ${INT} -e 3 -r ${REF} -i ${MOV} ${ARRAY[@]} -o ${OUT}"

if [ ${VERB} -eq 1 ]; then
  echo ${cmd}
  echo
fi 

# eval doesn't quit script like 'exec' does
eval ${cmd}

# check if we need to set s/qform code
res=`check_function fslorient`
if [[ ${res} -eq 0 ]]; then
  qform=`fslorient -getqformcode ${OUT}`
  sform=`fslorient -getsformcode ${OUT}`

  # set qform with sform
  if [[ ${qform} -eq 0 ]]; then
    if [[ ${sform} -ne 0 ]]; then
      fslorient -copysform2qform ${OUT}
    fi
  fi

  # set sform with qform [MOST LIKELY THE CASE]
  if [[ ${sform} -eq 0 ]]; then
    if [[ ${qform} -ne 0 ]]; then
      fslorient -copyqform2sform ${OUT}
    fi
  fi 
fi

# # apply genaff + invwarp;
# call_antsapplytransforms -v -i "1 0" -t gen \
#   /data1/projects/MicroFunc/Jurjen/projects/hemifield/derivatives/pymp2rage/sub-005/ses-1/sub-005_ses-1_acq-MP2RAGE_T1w.nii.gz \
#   /data1/projects/MicroFunc/Jurjen/programs/linescanning/linescanning/bin/utils/MNI152_T1_1mm_Dil3_sagsinus_mask.nii.gz \
#   sub-005_ses-1_space-T1w_desc-MNI152_sinus.nii.gz \
#   "sub-005_genaff.mat sub-005_1InverseWarp.nii.gz"
